# 操作系统的运行环境

## 操作系统的运行机制

两种指令:特权指令和非特权指令;

两种处理器状态:用户态(目态)和核心态(管态);

两种程序:内核程序和应用程序.

---

计算机系统中，通常CPU执行两种不同性质的程序:

1. 一种是操作系统内核程序;
2. 另一种是用户自编程序(即系统外层的应用程序，或简称“应用程序”)。

对操作系统而言，这两种程序的作用不同，前者是后者的管理者，因此“管理程序”(即内核程序)要执行一些特权指令，而“被
管理程序”(即用户自编程序)出于安全考虑不能执行这些指令。

所谓<font color="#ea66a6">特权指令</font>，是指计算机中<font color="#faa755">不允许用户直接使用的指令</font>，如I/O指令、置中断指令，存取用于内存保护的寄存器、送程序状态字到程序状态字寄存器等的指令。

在具体实现上，将CPU的状态划分为<font color="#ea66a6">用户态(目态)</font>和<font color="#ea66a6">核心态(又称管态、内核态)</font>。可以理解为CPU内部有一个小开关，

+ 当小开关为1时，CPU处于核心态，此时CPU可以执行特权指令；
+ 当小开关为0时，CPU处于用户态，此时CPU只能执行非特权指令。

<font color="#ea66a6">用户自编程序</font>运行在用户态，<font color="#ea66a6">操作系统内核程序</font>运行在核心态。

在软件工程思想和结构程序设计方法影响下诞生的现代操作系统,几乎都是层次式的结构。操作系统的各项功能分别被设置在不同的层次上。

一些与硬件关联较紧密的模块，如时钟管理、中断处理、设备驱动等处于最低层。其次是运行频率较高的程序，如进程管理、存储器管理和设备管理等。这两部分内容构成了<font color="#ea66a6">操作系统的内核</font>。这部分内容的指令操作工作在核心态。

内核是计算机上配置的底层<font color="#faa755">软件</font>，是计算机功能的延伸,是操作系统最基本、最核心的部分。不同系统对内核的定义稍有区别，大多数操作系统内核包括4方面的内容。

1. 时钟管理

   在计算机的各种部件中，时钟是最关键的设备。时钟的第一功能是<font color="#faa755">计时</font>，操作系统需要通过时钟管理，向用户提供标准的系统时间。另外，通过<font color="#faa755">时钟中断的管理</font>，可以实现进程的切换。例如，在分时操作系统中采用时间片轮转调度，在实时系统中按截止时间控制运行，在批处理系统中通过时钟管理来衡量一个作业的运行程度等。因此，系统管理的方方面面无不依赖于时钟。

2. 中断机制

   引入中断技术的初衷是提高多道程序运行环境中CPU的利用率，而且主要是针对外部设备的。后来逐步得到发展，形成了多种类型，成为操作系统各项操作的基础。例如，键盘或鼠标信息的输入、进程的管理和调度、系统功能的调用、设备驱动、文件访问等，无不依赖于中断机制。可以说，现代操作系统是靠中断驱动的软件。

   中断机制中，只有一小部分功能属于内核，它们负责保护和恢复中断现场的信息，转移控制权到相关的处理程序。这样可以减少中断的处理时间，提高系统的并行处理能力。

3. 原语
   

按层次结构设计的操作系统，底层必然是一些可被调用的公用小程序，它们各自完成一个规定的操作。它们的特点如下:

+ 处于操作系统的最低层，是最接近硬件的部分。
  
+ 这些程序的运行具有<font color="#faa755">原子性</font>，其操作只能一气呵成(主要从系统安全性和便于管理考虑)。
  
+ 这些程序的运行时间都较短，而且调用频繁。
  
   通常把具有这些特点的程序称为原语(Atomic Operation)。定义原语的直接方法是关闭中断，让其所有动作不可分割地完成后再打开中断。
   系统中的设备驱动、CPU切换、进程通信等功能中的部分操作都可定义为原语，使它们成为内核的组成部分。
4. 系统控制的数据结构及处理.

   系统中用来登记状态信息的数据结构很多，如作业控制块、进程控制块(PCB)、设备控制块、各类链表、消息队列、缓冲区、空闲区登记表、内存分配表等。为了实现有效的管理，系统需要一些基本的操作，常见的操作有以下3种:

   + 进程管理。进程状态管理、进程调度和分派、创建与撤销进程控制块等。
   + 存储器管理。存储器的空间分配和回收、内存信息保护程序、代码对换程序等。
   + 设备管理。缓冲区管理、设备分配和回收等。
   

从上述内容可以了解，核心态指令实际上包括系统调用类指令和一些针对时钟、中断和原语的操作指令。

## 大内核和微内核

操作系统的体系结构是一个开放的问题 。 如上文所述，操作系统在核心态为应用程序提供公共的服务，那么操作系统在核心态应该提供什么服务、怎样提供服务？有关这一 问题的回答形成了两种主要的体系结构：大内核和微内核 。

大内核系统将操作系统的主要功能模块都作为一个紧密联系的整体运行在核心态，从而为应用提供高性能的系统服务 。 因为各管理模块之间共享信息，能有效利用相互之间的有效特性，所以具有无可比拟的性能优势 。

但随着体系结构和应用 需求的不断发展，需要操作系统提供的服务越来越多，而且接口形式越来越复杂，操作系统的设计规模急剧增长，操作系统也面临着 “软件危机”困境 。 为此，操作系统设计人员试图按照复杂性、时间常数、抽象级别等因素，将操作系统内核分成基本进程管理 、虚存、I/O 与设备管理、IPC 、文件系统等几个层次，继而定义层次之间的服务结构，提高操作系统内核设计上的模块化。 但是，由于层次之间的交互关系错综复杂 ，定义清晰的层次间接口非常困难，复杂的交互关系也使得层次之间的界限极其模糊。

为解决操作系统的内核代码难以维护的问题，提出了微内核的体系结构 。 它将内核中最基本的功能（如进程管理等 ）保留在内核，而将那些不需要在核心态执行的功能移到用户态执行，从而降低了内核的设计复杂性 。 那些移出内核的操作系统代码根据分层的原则被划分成若干服务程序，它们的执行相互独立，交互则都借助于微内核进行通信。

微内核结构有效地分离了内核与服务、服务与服务，使得它们之间的接口更加清晰，维护的代价大大降低，各部分可以独立地优化和演进 ，从而保证了操作系统的可靠性。

微内核结构的最大问题是性能问题，因为需要频繁地在核心态和用户态之间进行切换，操作系统的执行开销偏大 。 因此有的操作系统将那些频繁使用的系统服务又移回内核，从而保证系统性能。但相当多的实验数据表明，体系结构不是引起性能下降的主要因素，体系结构带来的性能提升足以弥补切换开销带来的缺陷 。 为减少切换开销，也有人提出将系统服务作为运行库链接到用户程序的一种解决方案，这样的体系结构称为库操作系统。

## <font color="#33a3dc">中断和异常的概念</font>

1. 当中断发生时，CPU立即进入核心态（并且是进入核心态的<font color="#FF666">唯一方式</font>）
2. 当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理
3. 对于不同的中断信号，会进行不同的处理

在操作系统中引入核心态和用户态这两种工作状态后，就需要考虑这两种状态之间如何切换 。操作系统内核工作在核心态，而用户程序工作在用户态 。系统不允许用户程序实现核心态的功能，而它们又必须使用这些功能 。因此，需要在核心态建立一些“门”以便实现从用户态进入核心态 。

在实际操作系统中，CPU 运行上层程序时唯一能进入这些“门”的途径就是通过中断或异常。发生中断或异常时，运行用户态的 CPU 会主即进入核心态，这是通过硬件实现的（例如，用一个特殊寄存器的一位来表示CPU所处的工作状态，0表示核心态，1表示用户态。若要进入核心态，则只需将该位置0即可)。

中断是操作系统中非常重要的一个概念，对一个运行在计算机上的实用操作系统而言，缺少了中断机制，将是不可想象的。原因是，操作系统的发展过程大体上就是一个想方设法不断提高资源利用率的过程，而提高资源利用率就需要在程序并未使用某种资源时，把它对那种资源的占有权释放，而这一行为就需要通过中断实现。

### <font color="#33a3dc">中断和异常的定义</font>

中断(Interruption)也称<font color="#faa755">外中断</font>，指来自CPU执行<font color="#faa755">指令以外</font>的事件的发生，如设备发出的I/O结束中断，表示设备输入/输出处理已经完成，希望处理机能够向设备发下一个输入/输出请求,同时让完成输入/输出后的程序继续运行。时钟中断，表示一个固定的时间片已到，让处理机处理计时、启动定时运行的任务等。这一类中断通常是与当前指令执行无关的事件，即它们与当前处理机运行的程序无关。

异常(Exception)也称<font color="#faa755">内中断</font>、例外或陷入(trap),指源自CPU执行<font color="#faa755">指令内部</font>的事件，如程序的非法操作码、地址越界、算术溢出、虚存系统的缺页及专门的陷入指令等引起的事件。对异常的处理一般要依赖于当前程序的运行现场，而且异常不能被屏蔽，一旦出现应立即处理。关于内中断和外中断的联系与区别如图1.2 所示。

<img src="../../../../../Image/1.3 操作系统的运行环境/内中断和外中断的联系与区别.png" alt="内中断和外中断的联系与区别" style="object-fit: cover; border-radius: 10px; width: 80%;" />

### 中断处理的过程

不同计算机的中断（指外中断〉处理过程各具特色，所示。各阶段处理流程的描述如下：

1. 关中断 。CPU 响应中断后，首先要保护程序的现场状态，在保护现场的过程中，CPU 不应响应更高级中断源的中断请求。否则，若现场保存不完整，在中断服务程序结束后，也就不能正确地恢复并继续执行现行程序 。
2. 保存断点。为保证中断服务程序执行完毕后能正确地运回到原来的程序，必须将原来的程序的断点（即程序计数器 PC）保存起来。
3. 引出中断服务程序 。其实质是取出中断服务程序的入口地址送入程序计数器 PC 。
4. 存现场和屏蔽字。 进入中断服务程序后 ，首先要保存现场，现场信息一般是指程序状态字寄存器 PSWR 和某些通用寄存器的内容。
5. 开中断。 允许更高级中断请求得到响应。
6. 执行中断服务程序。这是中断请求的目的。
7. 关中断。保证在恢复现场和屏蔽字时不被中断。
8. 恢复现场和屏蔽字。将现场和屏蔽字恢复到原来的状态。
9. 开中断、中断返回。中断服务程序的最后一条指令通常是一条中断返回指令，使其返回到原程序的断点处，以便继续执行原程序 。

其中，1\~3步是在 CPU 进入中断周期后，由硬件自动（中断隐指令）完成的；4\~9 步由中断服务程序完成。恢复现场是指在中断返回前，必须将寄存器的内容恢复到中断处理前的状态，这部分工作由中断服务程序完成 。中断返回由中断服务程序的最后一条中断返回指令完成。

## 系统调用

所谓<font color="#ea66a6">系统调用</font>， 是指用户在程序中调用操作系统所提供的一些子功能，系统调用可视为特殊的公共子程序。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作（如存储分配、进行 I/0 传输及管理文件等），都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成 。 通常，一个操作系统提供的系统调用命令有几十条乃至上百条之多。这些系统调用按功能大致可分为如下几类。

+ 设备管理。完成设备的请求或释放，以及设备启动等功能。
+ 文件管理。完成文件的读、写、创建及删除等功能。
+ 进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。
+ 进程通信。完成进程之间的消息传递或信号传递等功能。
+ 内存管理。完成内存的分配、回收以及获取作业占用内存区大小及始址等功能。

显然，系统调用相关功能涉及系统资源管理、进程管理之类的操作，对整个系统的影响非常大，因此必定需要使用某些特权指令才能完成，所以系统调用的处理需要由操作系统内核程序负责完成，要运行在核心态。

用户程序可以执行陷入指令(又称访管指令或trap指令)来发起系统调用，请求操作系统提供服务。可以这么理解，用户程序执行“陷入指令”，相当于把CPU的使用权主动交给操作系统内核程序(CPU状态会从用户态进入核心态)，之后操作系统内核程序再对系统调用请求做出相应处理。处理完成后，操作系统内核程序又会把CPU的使用权还给用户程序(即CPU状态会从核心态回到用户态)。这么设计的目的是:用户程序不能直接执行对系统影响非常大的操作，必须通过系统调用的方式请求操作系统代为执行，以便保证系统的稳定性和安全性，防止用户程序随意更改或访问重要的系统资源，影响其他进程的运行。

这样，操作系统的运行环境就可以理解为:用户通过操作系统运行上层程序(如系统提供的命令解释程序或用户自编程序)，而这个上层程序的运行依赖于操作系统的底层管理程序提供服务支持，当需要管理程序服务时，系统则通过硬件中断机制进入核心态，运行管理程序;也可能是程序运行出现异常情况，被动地需要管理程序的服务，这时就通过异常处理来进入核心态。管理程序运行结束时，用户程序需要继续运行，此时通过相应的保存的程序现场退出中断处理程序或异常处理程序，返回断点处继续执行，如图1.4 所示。

<img src="../../../../../Image/1.3 操作系统的运行环境/系统调用执行过程.png" alt="系统调用执行过程" style="object-fit: cover; border-radius: 10px; width: 100%;;" />

在操作系统这一层面上，我们关心的是系统核心态和用户态的软件实现与切换，对于硬件层面的具体理解，可以结合 “计算机组成原理”课程中有关中断的内容进行学习 。

下面列举一些由用户态转向核心态的例子：

1. 用户程序要求操作系统的服务，即系统调用。
2. 发生一次中断。
3. 用户程序中产生了一个错误状态。
4. 用户程序中企图执行一条特权指令。
5. 从核心态转向用户态由一条指令实现， 这条指令也是特权命令，一般是中断返回指令。

注意:由用户态进入核心态，不仅状态需要切换，而且所用的堆栈也可能需要由用户堆栈切换为系统堆栈，但这个系统堆栈也是属于该进程的。

若程序的运行由用户态转到核心态，则会用到<font color="#faa755">访管指令(陷入指令)</font>，访管指令是在用户态使用的，发出系统调用请求，所以它不可能是特权指令。

陷入指令是唯一一个只能在用户态执行，而不可在核心态执行的指令。 

