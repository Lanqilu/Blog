# 处理机调度

## 调度概念

### 调度的基本概念

在多道程序系统中，进程的数量往往多于处理机的个数，因此进程争用处理机的情况在所难免。处理机调度是对处理机进行<font color="#faa755">分配</font>，即从就绪队列中按照一定的算法(公平、高效)选择一个进程并将处理机分配给它运行，以实现进程并发地执行。

<font color="#faa755">处理机调度是多道程序操作系统的基础，是操作系统设计的核心问题。</font>

### 调度的层次

一个作业从提交开始直到完成，往往要经历以下三级调度：

1. <font color="#faa755">作业调度</font>。又称高级调度，其主要任务是按一定的原则从外存上处于后备状态的作业中挑选一个(或多个)作业，给它(们)分配内存、输入/输出设备等必要的资源，并<font color="#faa755">建立相应的进程</font>(建立PCB)，以使它(们)<font color="#faa755">获得竞争处理机的权利</font>。简言之，作业调度就是内存与辅存之间的调度。对于每个作业只调入一次、调出一次。多道批处理系统中大多配有作业调度，而其他系统中通常不需要配置作业调度。作业调度的执行频率较低，通常为几分钟一次。

   > 高级调度是辅存(外存)与内存之间的调度。每个作业只调入一次，调出一次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。

2. 中级调度。又称<font color="#faa755">内存调度</font>，其作用是<font color="#faa755">提高内存利用率</font>和<font color="#faa755">系统吞吐量</font>。为此，应将那些暂时不能运行的进程<font color="#faa755">调至外存等待</font>(虚拟内存)，把此时的进程状态称为<font color="#FF666">挂起态</font>。当它们已具备运行条件且内存又稍有空闲时，由中级调度来决定把外存上的那些已具备运行条件的就绪进程，再重新调入内存，并修改其状态为就绪态，挂在就绪队列上等待。

   > 暂时调到外存等待的进程状态为挂起状态。值得注意的是，PCB并不会一起调到外存，而是会常驻内存。PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。被挂起的进程PCB会被放到的<font color="#faa755">挂起队列</font>中。一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。

   > 暂时调到外存等待的进程状态为挂起状态(挂起态，suspend)，挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态。五状态模型→七状态模型

   <img src="../../../../../Image/2.2 处理机调度/七状态模型.png" alt="七状态模型" style="object-fit: cover; border-radius: 10px; width: 100%;" />

3. <font color="#faa755">进程调度</font>。又称低级调度，其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。进程调度是操作系统中<font color="#FF666">最基本的一种调度</font>，在一般的操作系统中都必须配置进程调度。进程调度的<font color="#faa755">频率很高</font>，一般几十毫秒一次。

<img src="../../../../../Image/2.2 处理机调度/处理机的三级调度.png" alt="处理机的三级调度" style="object-fit: cover; border-radius: 10px; width: 100%;" />

|                    | 要做什么                                                     | 调度发生在          | 发生频率 | 对进程状态的影响               |
| ------------------ | ------------------------------------------------------------ | ------------------- | -------- | ------------------------------ |
| 高级调度(作业调度) | 按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程 | 外存→内存(面向作业) | 最低     | 无→创建态→就绪态               |
| 中级调度(内存调度) | 按照某种规则，从挂起队列中选择合适的进程将其数据调回内存     | 外存→内存(面向进程) | 中等     | 挂起态→就绪态(阻塞挂起→阻塞态) |
| 低级调度(进程调度) | 按照某种规则，从就绪队列中选择一个进程为其分配处理机         | 内存→CPU            | 最高     | 就绪态→运行态                  |

### 三级调度的联系

作业调度从外存的后备队列中选择一批作业进入内存，为它们建立进程，这些进程被送入就绪队列，进程调度从就绪队列中选出一个进程，并把其状态改为运行态，把CPU分配给它。

中级调度是为了提高内存的利用率，系统将那些暂时不能运行的进程挂起来。当内存空间宽松时，通过中级调度选择具备运行条件的进程，将其唤醒。

1. 作业调度为进程活动做准备，进程调度使进程正常活动起来，中级调度将暂时不能运行的进程挂起，中级调度处于作业调度和进程调度之间。
2. 作业调度次数少，中级调度次数略多，进程调度频率最高。
3. 进程调度是最基本的，不可或缺。

## 调度的时机、切换与过程

### 调度的时机

进程调度和切换程序是操作系统内核程序。

<font color="#faa755">需要进行进程调度与切换的情况</font>：

+ 当前运行的进程<font color="#faa755">主动放弃</font>处理机：进程正常终止；运行过程中发生异常而终止；进程主动请求阻塞(如等待I/O)
+ 当前运行的进程<font color="#faa755">被动放弃</font>处理机：分给进程的时间片用完；有更紧急的事需要处理(如I/O中断)；有更高优先级的进程进入就绪队列

请求调度的事件发生后，才可能运行进程调度程序，调度了新的就绪进程后，才会进行进程间的切换。理论上这三件事情应该顺序执行，但在实际设计中，操作系统内核程序运行时，若某时发生了引起进程调度的因素，则不一定能够马上进行调度与切换。

现代操作系统中，<font color="#faa755">不能进行进程的调度与切换的情况</font>有以下几种：

1. <font color="#faa755">在处理中断的过程中</font>。中断处理过程复杂，在实现上很难做到进程切换，而且中断处理是系统工作的一部分，逻辑上不属于某一进程，不应被剥夺处理机资源。

2. <font color="#faa755">进程在操作系统内核程序临界区中</font>。进入临界区后，需要独占式地访问共享数据，理论上必须加锁，以防止其他并行程序进入，在解锁前不应切换到其他进程运行，以加快该共享数据的释放。

   > 临界资源：一个时间段内只允许一个进程使用的资源。各进程需要<font color="#faa755">互斥</font>地访问临界资源
   >
   > 临界区：访问临界资源的那段代码。
   >
   > 内核程序临界区一般是用来访问某种内核数据结构的，比如进程的就绪队列(由各就绪进程的PCB组成)

   > 如果还没退出内核程序临界区(还没解锁)就进行进程调度，但是进程调度相关的程序也需要访问就绪队列，但此时就绪队列被锁住了，因此又无法顺利进行进程调度，内核程序临界区访问的临界资源如果不尽快释放的话，极有可能
   > 影响到操作系统内核的其他管理工作。因此在访问内核程序临界区期间不能进行调度与切换。
   >
   > 在打印机打印完成之前，进程一直处于临界区内，临界资源不会解锁。但打印机又是慢速设备，此时如果一直不允许进程调度的话就会导致CPU一直空闲，普通临界区访问的临界资源不会直接影响操作系统内核的管理工作。因此在访问普通临界区时可以进行调度与切换。

3. <font color="#faa755">其他需要完全屏蔽中断的原子操作过程中</font>。如加锁、解锁、中断现场保护、恢复等原子操作。在原子过程中，连中断都要屏蔽，更不应该进行进程调度与切换。

若在上述过程中发生了引起调度的条件，则不能马上进行调度和切换，应置系统的请求调度标志，直到上述过程结束后才进行相应的调度与切换。应该进行进程调度与切换的情况如下：

1. 发生引起调度条件且当前进程无法继续运行下去时，可以马上进行调度与切换。若操作系统只在这种情况下进行进程调度，则是<font color="#faa755">非剥夺调度</font>。
2. 中断处理结束或自陷处理结束后，返回被中断进程的用户态程序执行现场前，若置上请求调度标志，即可马上进行进程调度与切换。若操作系统支持这种情况下的运行调度程序，则实现了<font color="#faa755">剥夺方式</font>的调度。

### 调度的切换与过程

进程切换往往在调度完成后立刻发生，它要求<font color="#faa755">保存原进程当前切换点的现场信息</font>，<font color="#faa755">恢复被调度进程的现场信息</font>。

1. 对原来运行进程各种数据的保存
2. 对新的进程各种数据的恢复

现场切换时，操作系统内核将原进程的现场信息推入当前进程的内核堆栈来保存它们，并更新堆栈指针。内核完成从新进程的内核栈中装入新进程的现场信息、更新当前运行进程空间指针、重设PC寄存器等相关工作之后，开始运行新的进程。

> 注意：进程切换是<font color="#faa755">有代价的</font>，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。

“狭义的进程调度”与“进程切换"的区别：

+ 狭义的进程调度指的是从就绪队列中选中一个要运行的进程。(这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换)

+ 进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程。

广义的进程调度包含了选择一个进程和进程切换两个步骤。

## 进程调度方式

所谓进程调度方式，是指当某个进程正在处理机上执行时，若有某个更为重要或紧迫的进程需要处理，即有优先权更高的进程进入就绪队列，此时应如何分配处理机。通常有以下两种进程调度方式:

1. 非剥夺调度方式，又称非抢占方式。非剥夺调度方式是指当-一个进程正在处理机上执行时，即使有某个更为重要或紧迫的进程进入就绪队列，仍然让正在执行的进程继续执行，直到该进程完成或发生某种事件而进入阻塞态时，才把处理机分配给更为重要或紧迫的进程。

   > 在非剥夺调度方式下，一旦把CPU分配给-一个进程，该进程就会保持CPU直到终止或转换到等待态。这种方式的优点是实现简单、系统开销小，适用于大多数的批处理系统，但它不能用于分时系统和大多数的实时系统。

2. 剥夺调度方式，又称抢占方式。剥夺调度方式是指当一个进程正在处理机上执行时，若有某个更为重要或紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给这个更为重要或紧迫的进程。

   > 采用剥夺式的调度，对提高系统吞吐率和响应效率都有明显的好处。但“剥夺”不是一种任意性行为，必须遵循一定的原则，主要有优先权、短进程优先和时间片原则等。

## 调度的基本准则

不同的调度算法具有不同的特性，在选择调度算法时，必须考虑算法的特性。为了比较处理机调度算法的性能，人们提出了很多评价准则，下 面介绍其中主要的几种:

1. CPU利用率。CPU是计算机系统中最重要和昂贵的资源之一，所以应尽可能使CPU保持“忙”状态，使这一资源利用率最高。<font color="#faa755">利用率=忙碌的时间/总时间</font>。

2. 系统吞吐量。表示单位时间内CPU完成作业的数量。长作业需要消耗较长的处理机时间，因此会降低系统的吞吐量。而对于短作业，它们所需要消耗的处理机时间较短，因此能提高系统的吞吐量 。调度算法和方式的不同，也会对系统的吞吐量产生较大的影响。<font color="#faa755">系统的吞吐量=总共完成了多少道作业/总共花了多少时间</font>。

3. 周转时间。周转时间是指从作业提交到作业完成所经历的时间，是作业等待、在就绪队列中排队、在处理机上运行及进行输入/输出操作所花费时间的总和。

   + <font color="#ea66a6">周转时间</font><font color="#faa755">＝作业完成时间-作业提交时问</font>；
   + <font color="#ea66a6">平均周转时间</font><font color="#faa755">＝各作业周转时间之和/作业数</font>；
   + <font color="#ea66a6">带权周转时间</font><font color="#faa755">=作业周转时间/作业实际运行时间</font>；
   + <font color="#ea66a6">平均带权周转时间</font><font color="#faa755">=各作业周转时间之和/作业数</font>；

4. 等待时间。等待时间指进程处于等处理机状态的时间之和，等待时间越长，用户满意度越低。处理机调度算法实际上并不影响作业执行或输入/输出操作的时间，只影响作业在就绪队列中等待所花的时间。因此，<font color="#faa755">衡量一个调度算法的优劣，常常只需简单地考察等待时间</font>。当然，与前面指标类似，也有“平均等待时间”来评价整体性能。

   > 对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间。
   >
   > 对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。

5. 响应时间。响应时间指从用户提交请求到系统首次产生响应所用的时间。在交互式系统中，周转时间不可能是最好的评价准则，一般采用响应时间作为衡量调度算法的重要准则之一。从用户角度来看，调度策略应尽量降低响应时间，使响应时间处在用户能接受的范围之内。

## 典型的调度算法

操作系统中存在多种调度算法，有的调度算法适用于作业调度，有的调度算法适用于进程调度 ，有的调度算法两者都适用。下面介绍几种常用的调度算法。

### 先来先服务(FCFS)调度算法

先来先服务(FCFS,First Come First Serve)调度算法是一种最简单的调度算法 ，它既可用于作业调度，又可用于进程调度。在作业调度中，算法每次从后备作业队列中选择最先进入该队列的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列。

在进程调度中，FCFS调度算法每次从就绪队列中选择最先进入该队列的进程，将处理机分配给它，使之投入运行，直到完成或因某种原因而阻塞时才释放处理机。

下面通过一个实例来说明FCFS调度算法的性能。假设系统中有4个作业，它们的提交时间分别是8, 8.4, 8.8, 9,运行时间依次是2, 1, 0.5, 0.2，系统采用FCFS调度算法，这组作业的平均等待时间、平均周转时间和平均带权周转时间见表2.2。

<img src="../../../../../Image/2.2 处理机调度/FCFS调度算法的性能.png" alt="FCFS调度算法的性能" style="object-fit: cover; border-radius: 10px; width: 100%;" />

FCFS调度算法属于不可剥夺算法。从表面上看，它对所有作业都是公平的，但若一个长作业先到达系统，就会使后面的许多短作业等待很长时间，因此它不能作为分时系统和实时系统的主要调度策略。但它常被结合在其他调度策略中使用。例如，在使用优先级作为调度策略的系统中，往往对多个具有相同优先级的进程按FCFS原则处理。

FCFS调度算法的特点是算法简单，但效率低；对长作业比较有利，但对短作业不利(相对SJF和高响应比) ；有利于CPU繁忙型作业，而不利于I/O繁忙型作业。

+ 算法思想：主要从“公平”的角度考虑(类似于我们生活中排队买东西的例子)。
+ 算法规则：按照作业/进程到达的先后顺序进行服务。事实上就是等待时间越久的越优先得到服务。
+ 用于作业/进程调度：用于作业调度时，考虑的是哪个作业先到达后备队列；用于进程调度时，考虑的是哪个进程先到达就绪队列。
+ 是否可抢占：非抢占式的算法
+ 优缺点：
  + 优点：公平、算法实现简单
  + 缺点：排在长作业(进程)后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好。即，FCFS算法对长作业有利，对短作业不利
+ 是否会导致饥饿：不会





















