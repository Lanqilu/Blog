---
title: LeetCode笔记
date: 2020-11-14 18:19:34
tags:
- 算法
categories:
- 算法
---





## 数组

### 26. [删除有序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

#### 题目描述

给你一个有序数组，请你原地删除重复出现的元素，使每个元素只出现一次 ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在原地修改输入数组 并在使用 O(1) 额外空间的条件下完成。

**示例 1:**

```
给定数组 nums = [1,1,2], 

函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 

你不需要考虑数组中超出新长度后面的元素。
```

**示例 2:**

```
给定 nums = [0,0,1,1,1,2,2,3,3,4],

函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。

你不需要考虑数组中超出新长度后面的元素。
```

 **说明:**

为什么返回数值是整数，但输出的答案是数组呢?

请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

```java
// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
```

#### 解法 双指针


利用双指针实现，初始时慢指针在索引0处，快指针在索引1处。将两指针解引的值进行比较:

1. 当两值相等时快指针向前，慢指针不动，继续比较。
2. 当两值不同时，慢指针相向一步，在将快指针的值赋给慢指针。
3. 最后慢指针对于索引值加1即为所需数组的长度。

```java
public  int removeDuplicatesByTwoPointer(int[] nums) {
    int n = nums.length;
    if (n == 0) {
        return 0;
    }
    int slow = 0;
    for (int fast = 1; fast < n; fast++) {
        if (nums[fast] != nums[slow]) {
            slow++;
            nums[slow] = nums[fast];
        }
    }
    return slow + 1;
}
```

#### 解法 记录重复项个数

定义`cnt`表示数组中重复的值的个数，例如`[1,1,1,1]`时，`cnt`的最终值为3。

从数组索引为1的值开始变量，与它前面的值继续比较，如果值相等将`cnt++`，当值不相等时，将当前`i`索引值赋值给`i-cnt`索引，该索引为不重复值的下一位（注意索引从0开始，列表长度从1开始）。

最后返回不重复值的个数为数组长度减去重复值的个数。


```java
public  int removeDuplicates(int[] nums) {
    int cnt = 0;
    int n = nums.length;
    for (int i = 1; i < n; ++i) {
        if (nums[i] == nums[i - 1]) {
            cnt++;
        }
        else {
            nums[i - cnt] = nums[i];
        }
    }
    return n - cnt;
}
```

### 80. [删除排序数组中的重复项 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii)

#### 题目描述

给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素<font color="#faa755">最多出现两次</font>，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

**示例 1:**

```
给定 nums = [1,1,1,2,2,3],

函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。

你不需要考虑数组中超出新长度后面的元素。
```

**示例 2:**

```
给定 nums = [0,0,1,1,1,1,2,3,3],

函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。

你不需要考虑数组中超出新长度后面的元素。
```

**说明:**

为什么返回数值是整数，但输出的答案是数组呢?

请注意，输入数组是以**“引用”**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

```
// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
```

#### 解法 覆盖多余重复项

从数组下标 1 开始遍历数组。

用计数器 `cnt` 记录当前数字重复出现的次数，`cnt` 的最小计数为 0；用 `cur` 记录新数组下个待覆盖的元素位置。

遍历时，若当前元素 `nums[i]` 与上个元素 `nums[i-1]` 相同，则计数器 +1，否则计数器重置为 0。如果计数器小于 2，说明当前元素 `nums[i]` 可以添加到新数组中，即：`nums[cur] = nums[i]`，同时 `cur++`。

遍历结果，返回 `cur` 值即可。

```java
public static int removeDuplicates(int[] nums) {
    int cnt = 0;
    int cur = 1;
    int n = nums.length;
    for (int i = 1; i < n; ++i) {
        if (nums[i] == nums[i - 1]) {
            cnt++;
        }
        else {
            cnt = 0;
        }
        if (cnt < 2) {
            nums[cur++] = nums[i];
        }
    }
    return cur;
}
```

#### 解法 删除多余重复项







###  1122. [数组的相对排序](https://leetcode-cn.com/problems/relative-sort-array/)

#### 题目

给你两个数组，`arr1` 和 `arr2`，

`arr2` 中的元素各不相同
`arr2` 中的每个元素都出现在 `arr1` 中
对 `arr1` 中的元素进行排序，使 `arr1` 中项的相对顺序和 `arr2` 中的相对顺序相同。未在 `arr2` 中出现过的元素需要按照升序放在 `arr1` 的末尾。

示例：

> 输入：`arr1 = [2,3,1,3,2,4,6,7,9,2,19]`,` arr2 = [2,1,4,3,9,6]`
> 输出：`[2,2,2,1,4,3,3,9,6,7,19]`


提示：

`arr1.length, arr2.length <= 1000`
`0 <= arr1[i], arr2[i] <= 1000`
`arr2` 中的元素 `arr2[i]` 各不相同
`arr2` 中的每个元素 `arr2[i]` 都出现在 `arr1` 中

#### 题解1





## 204. [计数质数](https://leetcode-cn.com/problems/count-primes/)

统计所有小于非负整数 `n` 的质数的数量。

示例 1：

```
输入：n = 10
输出：4
解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。
```


示例 2：

```
输入：n = 0
输出：0
```


示例 3：

```
输入：n = 1
输出：0
```