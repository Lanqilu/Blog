---
title: 设计模式
tags:
  - Spring
  - Java
categories:
  - []
date: 2020-07-30 12:28:27
---

{% note info no-icon %}

Spring中常用的设计模式

{% endnote %}

<!-- more -->

---

## 面向对象的七大设计原则

+ 开闭原则：对扩展开放，对修改关闭。
+ 里氏替换原则：继承必须确保超类所拥有的性质在子类中仍然成立。
+ 依赖倒置原则：要面向接口编程，不要面向实现编程。
+ 单一职责原则：控制类的粒度大小、将对象解耦、提高其内聚性。
+ 接口隔离原则：要为各个类建立它们需要的专用接口。
+ 迪米特法则：只与你的直接朋友交谈，不跟"陌生人”说话。
+ 合成复用原则：尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。

### 开闭原则

开闭原则（OCP）是指一个软件实体（如类、模块和函数）应该对扩展开放，对修改关闭。

开闭原则是面向对象设计中最基础的设计原则。例如版本更新，我们尽可能不修改源代码，但是可以增加新功能。

开闭原则的核心思想就是面向抽象编程

### 依赖倒置原则

依赖导致原则（DIP）是指设计代码结构时，高层模块不应该依赖低层模块，两者都应该依赖其抽象。抽象不应该依赖细节，细节应该依赖抽象。通过依赖倒置，可以减少类与类之间的耦合性，提高系统的稳定性，提高代码的可读性和可维护性，并能够降低修改程序所造成的风险。

### 单一职责原则

单一职责原则（SRP）是指不要存在多于一个导致类变更的原因。类、方法、接口单一

### 接口隔离原则

接口隔离原则（ISP）是指用多个专门的接口，而不使用单一的总接口，客户端不应该依赖他不需要的接口。指导接口的设计：

+ 一个类对另一个类的依赖应该建立在最小的接口之上
+ 建立单一接口，不要建立庞大臃肿的接口
+ 尽量细化接口，接口中的方法尽量少（适度）

### 迪米特原则

迪米特原则（LoD）是指一个对象应该对其他对象保持最少的了解，又叫最少知道原则（LKP），尽量降低类与类之间的耦合度。迪米特原则强调：只和朋友交流，不和陌生人说话。出现在成员变量、方法的输入、输出参数中的类都可以称为成员朋友类，而出现在方法体内部的类不属于朋友类。

### 里氏替换原则

### 合成复用原则



## Spring中常用的设计模式

设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。

正确使用设计模式具有以下优点：

+ 可以提高程序员的思维能力、编程能力和设计能力。
+ 使程序设计更加标准化、 代码编制更加工程化，使软件开发效率大大提高,从而缩短软件的开发周期
+ 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。

### 工厂模式

在大部分的情况下，我们都是以`new`关键字来创建对象的。举个例子，现实中车子的种类可能很多，有大巴车、轿车、救护车、越野车、卡车等，每个种类下面还有具体的型号，一个工厂生产如此多的车会难以管理，所以往往还需要进一步拆分为各个分工厂：大巴车、轿车等分工厂。但是客户不需要知道工厂是如何拆分的，他只会告诉客服需要什么车，客服会根据客户的需要找到对应的工厂去生产车。对客户而言，车厂只是一个抽象概念，他只是大概知道有这样的一个工厂能满足他的需要。

#### 普通工厂（Simple Factory）模式

在程序中往往也是如此，例如，有个 PRoduct的产品接口，它下面有5个实现类Product1、 Product2、 Product.3、 Product4、 Product5。它们属于一个大类，可以通过一个工厂去管理它们的生成，但是由于类型不同，所以初始化有所不同。为了方便使用产品工厂（ Product Factory）类来创建这些产品的对象，用户可以通过产品号来确定需要哪种产品。

不同的用户可能不知道彼此订了什么类型的产品，只知道对方订了产品，满足 PRoduct接口的定义，这样就有了 ProductFactory类的伪代码：

```java
public class ProductFactory {
    public static IProduct createProduct（String productNo）{
        switch (productIo){
            case "1":return new Product1(xxxx);
            case "2":return new Product2(xxxx);
            case "3":return new Product3(xxxx); 
            case "4":return new Product4(xxxx);
            case "5":return new Product5(xxxx);
            default: throw new
                NotSupportedException("未支持此编号产品生产。");
        }
    }
}
```

对于程序调用者而言，它只需要知道通过工厂的 `createProduct`方法，指定产品编号—— `productNo` 可以得到对应的产品，而产品满足接口 `IProduct` 的规范，所以初始化就简单了许多。对于产品对象的创建，可以把一些特有产品规则写入工厂类中。

#### 抽象工厂（ Abstract Factory）模式

抽象工厂模式可以向客户端提供一个接口，使得客户端在不必指定产品的具体情况下，创建多个产品族中的产品对象。

对于普通工厂而言，它解决了一类对象创建问题，但是有时候对象很复杂，有几十种，又分为几个类别。如果只有一个工厂，面对如此多的产品，这个工厂需要实现的逻辑就太复杂了，所以我们希望把工厂分成好几个，这样便于工厂产品规则的维护。但是设计者并不想让调用者知道具体的工厂规则，而只是希望他们知道有一个统一的工厂即可。这样的设计有助于对外封装和简化调用者的使用，毕竟调用者可不想知道选择具体工厂的规则。

仍以车厂为例，生产商不会把轿车、大巴车、警车、吉普车、救护车等车型都放在个车厂生产，那样会造成车厂异常复杂，从而导致难以管理和维护。所以，生产商通常会把它们按种类分为轿车厂、大巴车厂、警车厂、吉普车厂等分厂，每个种类下面有一些型号的产品。但是对于客户而言，只要告诉客服自己需要什么类型的车即可，至于如何分配给工厂那是客服的事情。

客户只是认为有一个能够生产各类车的工厂，它能生成我所需要的产品，这里工厂只是一个虚拟的概念，并不真实存在，它是通过车厂内部各个分厂去实现的，这个虚拟工厂被称为抽象工厂，它的各个分厂称为具体工厂。为了统一，需要制定一个接口规范（ IProductFactory），所有的具体工厂和抽象工厂都要实现这个接口， IProductFactory工厂接口就可以设计成：

### 单例模式



### 原型模式

### 代理模式

### 委派模式

### 策略模式

### 模板模式

### 适配器模式

### 装饰者模式

### 观察者模式

### 各种设计模式的总结与对比

#### Spring中常用的设计模式

| 设计模式   | 归纳                       | 举例                                                      |
| ---------- | -------------------------- | --------------------------------------------------------- |
| 工厂模式   | 只对结果负责，封装创建过程 | `BeanFactory`、`Calender`                                 |
| 单例模式   | 保障独一无二               | `ApplicationContext`、`Calender`                          |
| 原型模式   | 把一根毛，吹出千万个猴子   | `ArrayList`、`PrototypeBean`                              |
| 代理模式   | 找人办事，增强职责         | `ProxyFactoryBean`、`jdkDynamicAopProxy`、`CglibAopProxy` |
| 委派模式   | 干活算你的，功劳算我的     | `DispatcherServlet`、`BeanDefinitionParserDelegate`       |
| 策略模式   | 用户选择，结果统一         | `InstantiationStrategy`                                   |
| 模板模式   | 流程标准化，自己实现定制   | `jdbcTemplate`、`HttpServlet`                             |
| 适配器模式 | 兼容转换头                 | `AdvisorAdapter`、`HanderAdapter`                         |
| 装饰器模式 | 包装，同宗同源             | `BufferedReader`、`InputStream`、`OutputStream`           |
| 观察者模式 | 在任务完成时通知           | `ContextLoaderListener`                                   |

#### Spring中的编程思想总结

| Spring思想                 | 应用场景                                               | 归纳             |
| -------------------------- | ------------------------------------------------------ | ---------------- |
| OOP（面向对象编程）        | 用程序归纳总结生活中的一切事物                         | 封装、继承、多态 |
| BOP（面向Bean编程）        | 面向Bean（普通Java类）设计程序，解放程序员             | 一切从Bean开始   |
| AOP(面向切面编程) | 找出多个类中有一定规律的代码，开发时拆开，运行时再合并 |解耦，专人做专事|
| IoC（控制反转）    | 将new对象的动作交给Spring管理，并由Spring保存已创建的对象（IoC容器） | 转交控制权       |
| DI/DL（依赖注入/依赖查找） | Spring不仅保存自己创建的对象，而且保存对象与对象之间的关系。注入即赋值，主要有三种方式：构造方法、set方法、直接赋值 | 赋值 |


