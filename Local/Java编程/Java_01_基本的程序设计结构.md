---
title: Java基本程序设计结构
date: 2020-10-29 16:32:43
tags:
- Java
categories:
- Java基础
---

> 参考资料：《Java核心技术 卷Ⅰ》（第11版）、《Java编程思想》（第4版）、《OnJava8》、《写给大忙人的JavaSE9核心技术》

## Hello World

```java
// Java 是面向对象的语言，在Java程序中所有代码都必须在类中定义
public class HelloWorld {
    // main 方法是 Java 程序的入口方法，程序将从这里开始执行
    public static void main(String[] args){
        // 向控制台打印一条语句，Java程序严格区分大小写
        System.out.println("Hello, World!");
    }
}
```

## 基本类型

Java是一种强类型语言。这就意味着必须为每一个变量声明一种类型。

基本数据类型是CPU可以直接进行运算的类型。Java 支持八种基本数据类型，包括一种布尔类型、一种字符类型、四种整数类型和两种浮点数类型：

+ 整数类型：byte，short，int，long
+ 浮点数类型：float，double
+ 字符类型：char
+ 布尔类型：boolean

除了基本数据类型之外，Java 还支持称为引用类型的非基本数据类型：

+ 类（class）
+ 接口（interface）
+ 数组（array）

> Java有一个能够表示任意精度的算术包，通常称为“大数”（big number）。虽然称为大数但它并不是一种基本Java类型，而是一个Java对象。

### 基本数据类型

Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。

**byte**：

+ byte 数据类型是8位、有符号的，以二进制补码表示的整数；
+ 最小值是 **-128（-2<sup>7</sup>）**；
+ 最大值是 **127（2<sup>7</sup> -1）**；
+ 默认值是 **0**； 
+ byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；
+ 例子：`byte a = 100;`，`byte b = -50;`。

**short**：

+ short 数据类型是 16 位、有符号的以二进制补码表示的整数
+ 最小值是 **-32768（-2<sup>15</sup>）**；
+ 最大值是 **32767（2<sup>15</sup> - 1）**；
+ Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；
+ 默认值是 **0**；
+ 例子：`short s = 1000;`，`short r = -20000;`。

**int**：

+ int 数据类型是32位、有符号的以二进制补码表示的整数；
+ 最小值是 **-2,147,483,648（-2<sup>31</sup>）**；
+ 最大值是 **2,147,483,647（2<sup>31</sup> - 1）**；
+ 一般地整型变量默认为 int 类型；
+ 默认值是 **0** ；
+ 例子：`int a = 100000;`， `int b = -200000;`。

**long**：

+ long 数据类型是 64 位、有符号的以二进制补码表示的整数；
+ 最小值是 **-9,223,372,036,854,775,808（-2<sup>63</sup>）**；
+ 最大值是 **9,223,372,036,854,775,807（2<sup>63</sup> -1）**；
+ 这种类型主要使用在需要比较大整数的系统上；
+ 默认值是 **0L**；
+ 例子： `long a = 100000L;`，`long b = -200000L;`。
  "L"理论上不分大小写，但是若写成"l"容易与数字"1"混淆，不容易分辩。所以最好大写。

**float**：

+ float 数据类型是单精度、32位、符合IEEE 754标准的浮点数；
+ float 在储存大型浮点数组的时候可节省内存空间；
+ 默认值是 **0.0f**；
+ 浮点数不能用来表示精确的值，如货币；
+ 例子：`float f = 234.5f;`

**double**：

+ double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数；
+ 浮点数的默认类型为double类型；
+ double类型同样不能表示精确的值，如货币；
+ 默认值是 **0.0d**；
+ 例子：`double d = 123.4;`

**boolean**：

+ boolean数据类型表示一位的信息；
+ 只有两个取值：true 和 false；
+ 这种类型只作为一种标志来记录 true/false 情况；
+ 默认值是 **false**；
+ 例子：`boolean one = true;`

**char**：

+ char类型是一个**单一**的 16 位 Unicode 字符和转义字符
+ 最小值是 **\u0000**（即为0）；
+ 最大值是 **\uffff**（即为65,535）；
+ char 数据类型可以储存任何字符；
+ 例子：`char letter = 'A';  //使用单引号`

### 整数类型

整型用于表示没有小数部分的数值，允许是负数。

Java 中的整数类型有 byte、short、int 和 long 四种。这四种类型之间唯一的区别是位数，即能表示的数字范围有所不同。对于整型类型，Java只定义了带符号的整型，因此，最高位的bit表示符号位（0表示正数，1表示负数）。各种整型能表示的最大范围如下：

| 类型  | 存储要求 | 取值范围                                   |
| ----- | -------- | ------------------------------------------ |
| byte  | 1字节    | -128 ~ 127                                 |
| short | 2字节    | -32768 ~ 32767                             |
| int   | 4字节    | -2147483648 ~ 2147483647（超过20亿）       |
| long  | 8字节    | -9223372036854775808 ~ 9223372036854775807 |

> 在Java中，整型的范围与运行Java代码的机器无关。这就解决了软件从一个平台移植到另一平台，或者在同一平台中的不同操作系统之间进行移植给程序员带来的诸多问题。与此相反，C和C++程序会针对不同的处理器选择最为高效的整型。

+ 长整型数值有一个后缀L或l（如4000000000L）
+ 十六进制数值有一个前缀0x或0X（如0xCAFE）
+ 八进制有一个前缀0，例如，010对应十进制中的8。很显然，八进制表示法比较容易混淆
+ 从Java7开始，加上前缀0b或0B就可以写二进制数。例如，0b1001
+ 同样从Java7开始，还可以为数字字面量加下划线，如1_000_000。这些下划线只是为了让人更易读。Java编译器会去除这些下划线。

```Java
public class Main {
    public static void main(String[] args) {
        int i = 2147483647;
        int i2 = -2147483648;
        int i3 = 2_000_000_000; // 加下划线更容易识别
        int i4 = 0377;          // 使用八进制表示的十进制数255
        int i4 = 0xff0000;      // 十六进制表示的16711680
        int i5 = 0b1000000000;  // 二进制表示的512
        long l = 9000000000000000000L; // long型的结尾需要加L
    }
}
```

在 Java 中，如果整数运算超出了指定整数类型的范围，不会上溢或下溢，而是直接回绕。如果发生了这种情况，Java 编译器和解释器都不会发出任何形式的警告。进行整数运算时，必须确保使用的类型取值范围能满足计算需要。

```java
byte b1 = 127, b2 = 1;       // byte类型的最大值是127 
byte sum = (byte)(b1 + b2);  // 加法运算的结果直接回绕到-128，即byte类型的最小值
```

每一种整数类型都有对应的包装类：`Byte`、`Short`、`Integer` 和 `Long`。这些类都定义了 `MIN_VALUE` 和 `MAX_VALUE` 常量，表示相应的取值范围。而且还定义了一些有用的静态方法，例如`Byte.parseByte()` 和 `Integer.parseInt()`，作用是把字符串转换成整数。

### 浮点数类型

浮点类型用于表示有小数部分的数值

浮点类型的数就是小数，因为小数用科学计数法表示的时候，小数点是可以“浮动”的，如1234.5可以表示成12.345x10<sup>2</sup>，也可以表示成1.2345x10<sup>3</sup>，所以称为浮点数。

`float` 类型是 32 位单精度浮点数，`double` 是 64 位双精度浮点数。

对于`float`类型，需要加上`f`或`F`后缀。没有后缀`f`或`F`的浮点数值总是默认为`double`类型。

下面是定义浮点数的例子：

```Java
float f1 = 3.14f;
float f2 = 3.14e38f; // 科学计数法表示的3.14x10^38
double d = 1.79e308;
double d2 = -1.79e308;
double d3 = 4.9e-324; // 科学计数法表示的4.9x10^-324
```

浮点数可表示的范围非常大，`float`类型可最大表示3.4x10<sup>38</sup>，而`double`类型可最大表示1.79x10<sup>308</sup>。

除了表示普通的数字之外，`float` 和 `double` 类型还能表示四个特殊的值：

+ 正无穷大：如果浮点数运算的结果超出了 `float` 或 `double` 能表示的范围上限，得到的是正无穷大。
+ 负无穷大：如果浮点数的运算结果超出了 `float` 或 `double` 能表示的范围下限，得到的是负无穷大。
+ 零：Java 的浮点类型区分正零和负零，具体是哪个值取决于从哪个方向出现的下溢。在实际使用中，正零和负零的表现基本一样。
+ NaN：是“Not-a-Number”的简称，表示“不是数字”。如果浮点数运算不合法，例如 0.0/0.0，得到的就是 NaN。

```java
double inf = 1.0/0.0;          // 无穷大 
double neginf = -1.0/0.0;      // 负无穷大
double negzero = -1.0/inf;     // 负零 
double NaN = 0.0/0.0;          // NaN
```

Java 浮点数类型能处理到无穷大的上溢以及到零的下溢，因此浮点数运算从不抛出异常，就算执行非法运算也没事，例如零除以零，或计算负数的平方根。

float 和 double 基本类型都有对应的类，分别为 Float 和 Double。这两个类都定义了一些有用的常量：`MIN_VALUE`、`MAX_VALUE`、`NEGATIVE_INFINITY`、`POSITIVE_INFINITY` 和 `NaN`。

无穷大浮点数的表现和设想的一样，例如，无穷大之间的加减运算得到的还是无穷大。

负零的表现几乎和正零一样，而且事实上，相等运算符 == 会告诉你，负零和正零是相等的。区分负零、正零和普通的零有一种方法——把它作为被除数：1.0/0.0 得到的是正无穷大，但是 1.0 除以负零得到的是负无穷大。

因为 NaN 不是数字，所以 == 运算符会告诉我们它不等于任何其他数字，甚至包括它自己。若想检查某个 float 或double 值是否为 NaN，必须使用 `Float.isNaN()` 或 `Double.isNaN()` 方法。

> 浮点数值**不适用**无法接受舍入误差的金融计算。因是浮点数值采用二级制系统表示，而在二进制系统中无法精确地表示分数1/10。这就好像十进制无法精确地表示分数1/3一样。如果在数值计算中不允许有任何舍入误差，就应该使用`BigDecimal`类

### 布尔类型

布尔类型`boolean`只有`true`和`false`两个值，布尔类型总是关系运算的计算结果：

```Java
boolean b1 = true;
boolean b2 = false;
boolean isGreater = 5 > 3; // 计算结果为true
int age = 12;
boolean isAdult = age >= 18; // 计算结果为false
```

Java语言对布尔类型的存储并没有做规定，因为理论上存储布尔类型只需要1 bit，但是通常JVM内部会把`boolean`表示为4字节整数。

> 布尔类型既不是整数类型也不是对象类型，而且不能使用不兼容的值代替布尔类型（如不能使用1或0代表true和false）。

### 字符类型

字符类型`char`表示单个字符。

> 如今有些Unicode字符可以用一个`char`值描述，另外一些Unicode字符则需要两个`char`值。

Java的`char`类型除了可表示标准的ASCII外，还可以表示一个Unicode字符和转义字符（如`‘\n’`表示换行符），如果想在 Java 程序中使用字符字面量，只需把字符放在单引号中即可

```Java
public class Main {
    public static void main(String[] args) {
        char a = 'A';
        char zh = '中';
        System.out.println(a);
        System.out.println(zh);
    }
}
```

> 注意`char`类型使用**单引号**`'`，且仅有一个字符，要和双引号`"`的字符串类型区分开。

字符可以转换成整数类型，也可以从整数类型转换而来。字符类型对应的是 16 位整数类型。字符类型与 byte、short、int 和 long 不同，没有符号。Character 类定义了一些有用的静态方法（static method），用于处理字符，例如 `isDigit()`、`isJavaLetter()`、`isLowerCase()` 和 `toUpperCase()`。

### 基本类型之间的转换

**整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。**

转换从低级到高级。

```shell
byte ────▶short
               │
               ▼
char ────▶  int ────▶ long ────▶ float ────▶ double
```

数据类型转换必须满足如下规则：

+ 不能对boolean类型进行类型转换。
+ 不能把对象类型转换成不相关类的对象。
+ 在把容量大的类型转换为容量小的类型时必须使用强制类型转换。
+ 转换过程中可能导致溢出或损失精度。
+ 浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入。

## 变量

### 变量的声明

### 常量

定义变量的时候，如果加上`final`修饰符，这个变量就变成了常量：

```Java
final double PI = 3.14; // PI是一个常量
double r = 5.0;
double area = PI * r * r;
PI = 300; // compile error!
```

常量在定义时进行**初始化后就不可再次赋值**，再次赋值会导致编译错误。

常量的作用是用有意义的变量名来避免魔术数字（Magic number），例如，不要在代码中到处写`3.14`，而是定义一个常量。如果将来需要提高计算精度，我们只需要在常量的定义处修改，例如，改成`3.1416`，而不必在所有地方替换`3.14`。

根据习惯，**常量名通常全部大写**。

### var关键字

JDK 10引入

有些时候，类型的名字太长，写起来比较麻烦。例如：

```Java
StringBuilder sb = new StringBuilder();
```

这个时候，如果想省略变量类型，可以使用`var`关键字：

```Java
var sb = new StringBuilder();
```

编译器会根据赋值语句**自动推断**出变量`sb`的类型是`StringBuilder`。对编译器来说，语句：

```Java
var sb = new StringBuilder();
```

实际上会自动变成：

```Java
StringBuilder sb = new StringBuilder();
```

因此，使用`var`定义变量，仅仅是少写了变量类型而已。

### 变量的作用范围

在Java中，多行语句用{ }括起来。很多控制语句，例如条件判断和循环，都以{ }作为它们自身的范围，例如：

```Java
if (...) { // if开始
    ...
    while (...) { while 开始
        ...
        if (...) { // if开始
            ...
        } // if结束
        ...
    } // while结束
    ...
} // if结束
```

只要正确地嵌套这些{ }，编译器就能识别出语句块的开始和结束。而在语句块中定义的变量，它有一个作用域，就是从定义处开始，到语句块结束。超出了作用域引用这些变量，编译器会报错。举个例子：

```Java
{
    ...
    int i = 0; // 变量i从这里开始定义
    ...
    {
        ...
        int x = 1; // 变量x从这里开始定义
        ...
        {
            ...
            String s = "hello"; // 变量s从这里开始定义
            ...
        } // 变量s作用域到此结束
        ...
        // 注意，这是一个新的变量s，它和上面的变量同名，
        // 但是因为作用域不同，它们是两个不同的变量:
        String s = "hi";
        ...
    } // 变量x和s作用域到此结束
    ...
} // 变量i作用域到此结束
```

定义变量时，要遵循作用域最小化原则，尽量将变量定义在尽可能小的作用域，并且，不要重复使用变量名。

## 算术操作

表达式是 Java 程序更高一级的结构。Java 解释器会求出表达式的值。最简单的表达式叫基本表达式，由字面量和变量组成。基本表达式没什么意思，使用运算符把基本表达式连在一起可以组成复杂的表达式。不过，运算符不仅能连接基本表达式，也能在任意复杂度的表达式中使用。

### 运算符概述

一门编程语言能编写什么样的表达式，完全取决于可用的运算符。Java 提供了丰富的运算符，但在有效使用它们之前，要弄清两个重要的概念：优先级和结合性。

1. 优先级：优先级指定运算符执行的顺序。优先级高的运算符在优先级低的运算符之前运算。运算符默认的优先级可以使用括号改变，括号能明确指定运算的顺序。
2. 结合性：结合性是运算符的一个属性，定义如何计算有歧义的表达式。如果表达式中有多个优先级相同的运算符，结合性尤其重要。大多数运算符由左至右结合，即从左向右计算。不过，赋值和一元运算符由右至左结合。

| 优先级 | 结合性 | 运算符                                                       | 操作数类型         | 执行的运算               |
| ------ | ------ | ------------------------------------------------------------ | ------------------ | ------------------------ |
| 16     | L      | `.`                                                          | 对象，成员         | 访问对象成员             |
|        |        | `[]`                                                         | 数组，`int`        | 获取数组中的元素         |
|        |        | `( args )`                                                   | 方法，参数列表     | 调用方法                 |
|        |        | `++`，`--`                                                   | 变量               | 后递增、后递减           |
| 15     | R      | `++`，`--`                                                   | 变量               | 前递增、前递减           |
|        |        | `+`，`-`                                                     | 数字               | 正号、负号               |
|        |        | `~`                                                          | 整数               | 按位补码                 |
|        |        | `!`                                                          | 布尔值             | 逻辑求反                 |
| 14     | R      | `new`                                                        | 类，参数列表       | 创建对象                 |
|        |        | `( type )`                                                   | 类型，任何类型     | 校正（类型转化）         |
| 13     | L      | `\*`，`/`，`%`                                               | 数字，数字         | 乘法，除法，求余数       |
| 12     | L      | `+`，`-`                                                     | 数字，数字         | 加法，减法               |
|        |        | `+`                                                          | 字符串，任何类型   | 字符串连接               |
| 11     | L      | `<<`                                                         | 整数，整数         | 左移                     |
|        |        | `>>`                                                         | 整数，整数         | 右移，高位补符号         |
|        |        | `>>>`                                                        | 整数，整数         | 右移，高位补零           |
| 10     | L      | `<`，`<==`                                                   | 数字，数字         | 小于，小于或等于         |
|        |        | `>`，`>==`                                                   | 数字，数字         | 大于，大于或等于         |
|        |        | `instanceof`                                                 | 引用类型，类型     | 类型比较                 |
| 9      | L      | `==`                                                         | 基本类型，基本类型 | 等于（值相同）           |
|        |        | `!=`                                                         | 基本类型，基本类型 | 不等于（值不同）         |
|        |        | `==`                                                         | 引用类型，引用类型 | 等于（指向同一个对象）   |
|        |        | `!=`                                                         | 引用类型，引用类型 | 不等于（指向不同的对象） |
| 8      | L      | `&`                                                          | 整数，整数         | 位与                     |
|        |        | `&`                                                          | 布尔值，布尔值     | 逻辑与                   |
| 7      | L      | `^`                                                          | 整数，整数         | 位异或                   |
|        |        | `^`                                                          | 布尔值，布尔值     | 逻辑异或                 |
| 6      | L      | `|`                                                          | 整数，整数         | 位或                     |
|        |        | `|`                                                          | 布尔值，布尔值     | 逻辑或                   |
| 5      | L      | `&&`                                                         | 布尔值，布尔值     | 条件与                   |
| 4      | L      | `||`                                                         | 布尔值，布尔值     | 条件或                   |
| 3      | R      | `? :`                                                        | 布尔值，任何类型   | 条件（三元）运算符       |
| 2      | R      | `=`                                                          | 变量，任何类型     | 赋值                     |
|        |        | `*=`，`/=`,`%=`,`+=`,`-=`，`<<=`，`>>=`，`>>>=`,`&=`，`^=`，`^=`，`|=` | 变量，任何类型     | 计算后赋值               |
| 1      | R      | `->`                                                         | 参数列表，方法体   | lambda表达式             |

+ 数字：整数、浮点数或字符（即除了布尔类型之外的任何一种基本类型）。因为这些类型对应的包装类（例如 Character、Integer 和 Double）能自动拆包，所以在这些地方也能使用相应的包装类。
+ 整数：byte、short、int、long 或 char 类型的值（获取数组元素的运算符 [ ] 不能使用 long 类型的值）。因为能自动拆包，所以也能使用 Byte、Short、Integer、Long 和 Character 类型的值。
+ 引用类型：对象或数组。
+ 变量：变量或其他符号名称（例如数组中的元素），只要能赋值就行。

有些运算符只有一个操作数，这种运算符叫一元运算符。不过，大多数运算符都是二元运算符，有两个操作数。Java 还定义了一个三元运算符，经常称作条件运算符，就像是表达式中的 if 语句。它的三个操作数由问号和冒号分开，第二个和第三个操作数必须能转换成同一种类型：

```java
x > y ? x : y  // 三元表达式；计算x和y哪个大
```

### 算术运算符

Java的基本算术运算符与其他大多数程序设计语言是相同的。其中包括加号（`+`）、减号（`-`）、除号（`/`）、乘号（`*`）以及模数（`%`，从整数除法中获得余数）。

> 整数除法会直接砍掉小数，而不是进位。

Java也用一种简写形式进行运算，并同时进行赋值操作。这是由等号前的一个运算符标记的，而且对于语言中的所有运算符都是固定的。例如，为了将4加到变量x，并将结果赋给x，可用：`x+=4`。

#### 整数运算

 Java的整数运算遵循四则运算规则，可以使用任意嵌套的小括号。四则运算规则和初等数学一致。

```Java
public class Main {
    public static void main(String[] args) {
        int i = (100 + 200) * (99 - 88); // 3300
        int n = 7 * (5 + (i - 9)); // 23072
        System.out.println(i);
        System.out.println(n);
    }
}
```

整数的数值表示不但是精确的，而且整数运算永远是精确的，即使是除法也是精确的，因为两个整数相除只能得到结果的整数部分：

```Java
int x = 12345 / 67; // 184
```

求余运算使用`%`：

```Java
int y = 12345 % 67; // 12345÷67的余数是17
```

特别注意：整数的除法对于除数为0时运行时将报错，但编译不会报错。

#### 溢出

要特别注意，整数由于存在范围限制，如果计算结果超出了范围，就会产生溢出，而溢出**不会出错**，却会得到一个奇怪的结果：

```Java
public class Main {
    public static void main(String[] args) {
        int x = 2147483640;
        int y = 15;
        int sum = x + y;
        System.out.println(sum); // -2147483641
    }
}
```

要解释上述结果，我们把整数`2147483640`和`15`换成二进制做加法：

```ascii
  0111 1111 1111 1111 1111 1111 1111 1000
+ 0000 0000 0000 0000 0000 0000 0000 1111
-----------------------------------------
  1000 0000 0000 0000 0000 0000 0000 0111
```

由于最高位计算结果为`1`，因此，加法结果变成了一个负数。

要解决上面的问题，可以把`int`换成`long`类型，由于`long`可表示的整型范围更大，所以结果就不会溢出：

```Java
long x = 2147483640;
long y = 15;
long sum = x + y;
System.out.println(sum); // 2147483655
```

还有一种简写的运算符，即`+=`，`-=`，`*=`，`/=`，同Python，它们的使用方法如下：

```Java
n += 100; // 3409, 相当于 n = n + 100;
n -= 100; // 3309, 相当于 n = n - 100;
```

### 字符串连接运算符

`+`号（以及相关的 `+=` 运算符）除了能计算数字之和以外，还能连接字符串。如果 `+` 号的两个操作数中有一个是字符串，另一个操作数也会转换成字符串。

因此，如果加法和字符串连接结合在一起使用，要把加法表达式放在括号中。如果不这么做，加号会被理解成连接运算符。

Java 解释器原生支持把所有基本类型转换成字符串。对象转换成字符串时，调用的是对象的 `toString()` 方法。有些类自定义了 `toString()` 方法，所以这些类的对象可以使用这种方式轻易地转换成字符串。数组转换成字符串时会调用原生的 `toString()` 方法，不过可惜，这个方法没有为数组的内容提供有用的字符串形式。

### 递增和递减运算符

Java还提供了`++`运算和`--`运算，它们可以对一个整数进行加1和减1的操作：

```Java
public class Main {
    public static void main(String[] args) {
        int n = 3300;
        n++; // 3301, 相当于 n = n + 1;
        n--; // 3300, 相当于 n = n - 1;
        int y = 100 + (++n); // 不要这么写
        System.out.println(y);
    }
}
```

`++` 运算符把它的单个操作数增加 1，这个操作数必须是变量、数组中的元素或对象的字段。

这个运算符的行为取决于它相对于操作数的位置。`++n`表示先加1再引用n，`n++`表示先引用n再加1。

+ 放在操作数之前，是前递增运算符，递增操作数的值，并返回递增后的值。

+ 放在操作数之后，是后递增运算符，递增操作数的值，但返回递增前的值。

表达式 `x++` 和 `x--` 分别等效于 `x=x+1` 和 `x=x-1`，不过使用递增和递减运算符时，只会计算一次 x 的值。如果 x 是有副作用的表达式，情况就大不相同了。例如，下面两个表达式不等效：

```java
a[i++]++;             // 递增数组中的一个元素 
a[i++] = a[i++] + 1;  // 把数组中的一个元素增加1，然后把新值存储在另一个元素中 
```

这些运算符，不管放在前面还是后面，最常用来递增或递减控制循环的计数器。

### 比较运算符

比较运算符包括测试两个值是否相等的相等运算符和测试有序类型（数字和字符）数据之间大小关系的关系运算符。这两种运算符计算的结果都是布尔值，因此一般用于 if 语句、while 和 for 循环，作为分支和循环的判定条件。

Java 提供了下述相等运算符。

+ 等于（`==`）：如果 `==` 运算符的两个操作数相等，计算结果为 true；否则计算结果为 false。
  + 如果操作数是基本类型，这个运算符测试两个操作数的值是否一样。
  + 如果操作数是引用类型，这个运算符测试两个操作数是否指向同一个对象或数组。
  + 尤其要注意，这个运算符不能测试两个字符串是否相等。
  + 如果使用 `==` 比较两个数字或字符，而且两个操作数的类型不同，在比较之前会把取值范围窄的操作数转换成取值范围宽的操作数类型。例如，比较 short 类型的值和 float类型的值时，在比较之前会先把 short 类型的值转换成 float 类型。
  + 对浮点数来说，特殊的负零和普通的正零相等；特殊的 NaN 和任何数，包括 NaN 自己，都不相等。如果想测试浮点数是否为 NaN，要使用 `Float.isNan()` 或 `Double.isNan()` 方法。
+ 不等于（`!=`）：`!=` 运算符完全是 `==` 运算符的反运算。如果两个基本类型操作数的值不同，或者两个引用类型操作数指向不同的对象或数组，`!=` 运算符的计算结果为 true；否则，计算结果为 false。

关系运算符可用于数字和字符，但不能用于布尔值、对象和数组，因为这些类型无序。Java 提供了下述关系运算符：

+ 小于（`<`）：如果第一个操作数小于第二个操作数，计算结果为 true。
+ 小于或等于（`<=`）：如果第一个操作数小于或等于第二个操作数，计算结果为 true。
+ 大于（`>`）：如果第一个操作数大于第二个操作数，计算结果为 true。
+ 大于或等于（`>=`）：如果第一个操作数大于或等于第二个操作数，计算结果为 true。

### 逻辑运算符

逻辑运算符的操作数必须是布尔值，而且计算结果也是布尔值，对于布尔类型`boolean`，永远只有`true`和`false`两个值。

| a     | b     | a&b   | a&&b  | a\|b  | a\|\|b | !a    | a^b   |
| ----- | ----- | ----- | ----- | ----- | ------ | ----- | ----- |
| true  | true  | true  | true  | true  | true   | false | false |
| true  | false | false | false | true  | true   | false | true  |
| false | true  | false | false | true  | true   | true  | true  |
| false | false | false | false | false | false  | true  | false |

#### 条件与（`&&`）

这个运算符对操作数执行逻辑与运算。

+ 仅当两个操作数都是 true 时才返回 true；
+ 如果有一个或两个操作数都是 false，计算结果为 false。

这个运算符之所以叫条件与，是因为它会视情况决定是否计算第二个操作数。如果第一个操作数的结算结果为 false，不管第二个操作数的计算结果是什么，这个表达式的计算结果都是 false。因此，为了提高效率，Java 解释器会走捷径，跳过第二个操作数。（短路运算）因为不一定会计算第二个操作数，所以使用这个运算符时，如果表达式有副作用，一定要注意。类似的，对于`||`运算，只要能确定第一个值为`true`，后续计算也不再进行，而是直接返回`true`，不过，因为有这种特性，可以使用这个运算符编写如下的 Java 表达式：

```java
if (data != null && i < data.length && data[i] != -1) {
    //...
}
```

如果第一个和第二个比较表达式的计算结果为 false，第二个和第三个比较表达式会导致错误。幸好，我们无需为此担心，因为 `&&` 运算符会视情况决定是否执行后面的表达式。

#### 条件或（`||`）

这个运算符在两个布尔值操作数上执行逻辑或运算。如果其中一个或两个都是 true，计算结果为 true；如果两个操作数都是 false，计算结果为 false。

和 `&&` 运算符一样，`||` 并不总会计算第二个操作数。如果第一个操作数的计算结果为 true，不管第二个操作数的计算结果是什么，表达式的计算结果都是 true。因此，遇到这种情况时，`||` 运算符会跳过第二个操作数。

#### 逻辑非（`!`）

这个运算符改变操作数的布尔值。如果应用于 true，计算结果为 false；如果应用于false，计算结果为 true。

在下面这种表达式中很有用：

```java
if (!found) ...          // found是其他地方定义的布尔值 
while (!c.isEmpty()) ... // isEmpty()方法返回布尔值
```

`!` 是一元运算符，优先级高，经常必须使用括号：

```java
if (!(x > y && y > z))
```

#### 逻辑与（`&`）

如果操作数是布尔值，`&` 运算符的行为和 `&&` 运算符类似，但是不管第一个操作数的计算结果如何，总会计算第二个操作数。不过，这个运算符几乎都用作位运算符，处理整数操作数。很多 Java 程序员都认为使用这个运算符处理布尔值操作数是不合法的 Java代码。

#### 逻辑或（`|`）

这个运算符在两个布尔值操作数上执行逻辑或运算，和 `||` 运算符类似，但是就算第一个操作数的计算结果为 true，也会计算第二个操作数。`|` 运算符几乎都用作位运算符，处理整数操作数，很少用来处理布尔值操作数。

#### 逻辑异或（`^`）

如果操作数是布尔值，这个运算符的计算结果是两个操作数的异或。如果两个操作数中只有一个是 true，计算结果才是 true。也就是说，如果两个操作数都是 true 或 false，计算结果为 false。

这个运算符与 `&&` 和 `||` 不同，始终会计算两个操作数。`^` 运算符更常用作位运算符，处理整数操作数。如果操作数是布尔值，这个运算符等效于 `!=` 运算符。

### 位运算符和位移运算符

位运算符和位移运算符是低层运算符，处理组成整数的单个位。现代 Java 程序很少使用位运算符，除非处理低层操作（例如网络编程）。这两种运算符用于测试和设定整数中的单个标志位。若想理解这些运算符的行为，必须先理解二进制数以及用于表示负整数的二进制补码方式。

在计算机中，整数总是以二进制的形式表示。例如，`int`类型的整数`7`使用4字节表示的二进制如下：

```ascii
00000000 0000000 0000000 00000111
```

可以对整数进行移位运算。对整数`7`左移1位将得到整数`14`，左移两位将得到整数`28`：

```Java
int n = 7;       // 00000000 00000000 00000000 00000111 = 7
int a = n << 1;  // 00000000 00000000 00000000 00001110 = 14
int b = n << 2;  // 00000000 00000000 00000000 00011100 = 28
int c = n << 28; // 01110000 00000000 00000000 00000000 = 1879048192
int d = n << 29; // 11100000 00000000 00000000 00000000 = -536870912
```

左移29位时，由于最高位变成`1`，因此结果变成了负数。

类似的，对整数进行右移，结果如下：

```Java
int n = 7;       // 00000000 00000000 00000000 00000111 = 7
int a = n >> 1;  // 00000000 00000000 00000000 00000011 = 3
int b = n >> 2;  // 00000000 00000000 00000000 00000001 = 1
int c = n >> 3;  // 00000000 00000000 00000000 00000000 = 0
```

如果对一个负数进行右移，最高位的`1`不动，结果仍然是一个负数：

```Java
int n = -536870912;
int a = n >> 1;  // 11110000 00000000 00000000 00000000 = -268435456
int b = n >> 2;  // 10111000 00000000 00000000 00000000 = -134217728
int c = n >> 28; // 11111111 11111111 11111111 11111110 = -2
int d = n >> 29; // 11111111 11111111 11111111 11111111 = -1
```

还有一种不带符号的右移运算，使用`>>>`，它的特点是符号位跟着动，因此，对一个负数进行`>>>`右移，它会变成正数，原因是最高位的`1`变成了`0`：

```Java
int n = -536870912;
int a = n >>> 1;  // 01110000 00000000 00000000 00000000 = 1879048192
int b = n >>> 2;  // 00111000 00000000 00000000 00000000 = 939524096
int c = n >>> 29; // 00000000 00000000 00000000 00000111 = 7
int d = n >>> 31; // 00000000 00000000 00000000 00000001 = 1
```

对`byte`和`short`类型进行移位时，会首先转换为`int`再进行位移。

仔细观察可发现，左移实际上就是不断地×2，右移实际上就是不断地÷2。

---

+ 如果位运算符的操作数中有一个是 long 类型，结果就是 long 类型。除此之外，结果都是int 类型。

+ 如果位移运算符左边的操作数是 long 类型，结果为 long 类型；否则，结果是int 类型。

#### 按位补码（`~`）

一元运算符 `~` 是按位补码运算符，或叫位或运算符。它把单个操作数的每一位反相，1 变成 0，0 变成 1。

非运算的规则是，`0`和`1`互换：

```Java
n = ~0; // 1
n = ~1; // 0
```

#### 位与（`&`）

与运算的规则是，必须两个数同时为`1`，结果才为`1`：

```Java
n = 0 & 0; // 0
n = 0 & 1; // 0
n = 1 & 0; // 0
n = 1 & 1; // 1
```

#### 位或（`|`）

或运算的规则是，只要任意一个为`1`，结果就为`1`：

```Java
n = 0 | 0; // 0
n = 0 | 1; // 1
n = 1 | 0; // 1
n = 1 | 1; // 1
```

#### 位异或（`^`）

异或运算的规则是，如果两个数不同，结果为`1`，否则为`0`：

```Java
n = 0 ^ 0; // 0
n = 0 ^ 1; // 1
n = 1 ^ 0; // 1
n = 1 ^ 1; // 0
```

对两个整数进行位运算，实际上就是按位对齐，然后依次对每一位进行运算。例如：

```Java
public class Main {
    public static void main(String[] args) {
        int i = 167776589; // 00001010 00000000 00010001 01001101
        int n = 167776512; // 00001010 00000000 00010001 00000000
        System.out.println(i & n); // 167776512
    }
}

```

 上述按位与运算实际上可以看作两个整数表示的IP地址`10.0.17.77`和`10.0.17.0`，通过与运算，可以快速判断一个IP是否在给定的网段内。

#### 左移（`<<`）

`<<` 运算符把左侧操作数的每一位向左移动右侧操作数指定的位数。左侧操作数的高位被丢掉，右边缺少的位补零。整数向左移 n 位，相当于乘于 2<sup>n</sup>。

+ 如果左侧操作数是 long 类型，右侧操作数应该介于 0 和 63 之间。
+ 如果左侧操作数是 int 类型，右侧操作数应该介于 0 和 31 之间。

#### 带符号右移（`>>`）

`>>`运算符把左侧操作数的每一位向右移动右侧操作数指定的位数。左侧操作符的低位被移除，移入的高位和原来的最高位一样。也就是说，如果左侧操作数是正数，移入的高位是 0；如果左侧操作数是负数，移入的高位是 1。这种技术叫高位补符号，作用是保留左侧操作数的符号。

```java
10 >> 1     // 00001010 >> 1 = 00000101 = 5 = 10/2 
27 >> 3     // 00011011 >> 3 = 00000011 = 3 = 27/8 
-50 >> 2    // 11001110 >> 2 = 11110011 = -13 != -50/4
```

如果左侧操作数是正数，右侧操作数是 n，`>>` 运算符的计算结果相当于整数除以 2<sup>n</sup>。

#### 不带符号右移（`>>>`）

这个运算符和 `>>` 类似，但是不管左侧操作数的符号是什么，高位总是移入 0。这种技术叫高位补零。左侧操作数是无符号的数字时才适用这个运算符（可是 Java 的整数类型都带符号）。

```java
0xff >>> 4     // 11111111 >>> 4 = 00001111 = 15 = 255/16 
-50 >>> 2     // 0xFFFFFFCE >>> 2 = 0x3FFFFFF3 = 1073741811
```

### 赋值运算符

赋值运算符把值存储在某种变量中或赋予某种变量。左侧操作数必须是适当的局部变量、数组元素或对象字段。右侧操作数可以是与变量兼容的任何类型。赋值表达式的计算结果是赋予变量的值。不过，更重要的是，赋值表达式的副作用是执行赋值操作。和其他二运算符不同的是，赋值运算符是右结合的，也就是说，赋值表达式 a=b=c 从右向左执行，即 a=(b=c)。

除了这个简单的赋值运算符之外，Java 还定义了另外 11 个运算符，其中 5 个与算术运算符一起使用，6 个与位运算符和位移运算符一起使用。例如，`+=` 运算符先读取左侧变量的值，再和右侧操作数相加。这种表达式的副作用是把两数之和赋值给左侧变量，返回值也是两数之和。因此，表达式 `x+=2` 几乎和 `x=x+2` 一样。这两种表达式之间的区别是，`+=` 运算符只会计算一次左侧操作数。如果左侧操作数有副作用，这个区别就体现出来了。

### 条件运算符

条件运算符 `?:` 是有点晦涩的三元运算符（有三个操作数），从 C 语言继承而来，可以在一个表达式中嵌入条件判断。这个运算符可以看成是 if/else 语句的运算符版。条件运算符的第一个和第二个操作数使用问号（`?`）分开，第二个和第三个操作数使用冒号（`:`）分开。

第一个操作数的计算结果必须是布尔值。第二个和第三个操作数可以是任意类型，但要能转换成同一类型。

条件运算符先计算第一个操作数，如果结果为 true，就计算第二个操作数，并把结果当成表达式的返回值；如果第一个操作数的计算结果为 false，条件运算符会计算并返回第三个操作数。

条件运算符绝不会同时计算第二个和第三个操作数，所以使用有副作用的表达式时要小心。

```Java
public class Main {
    public static void main(String[] args) {
        int n = -100;
        int x = n >= 0 ? n : -n;
        System.out.println(x);
    }
}
```

上述语句的意思是，判断`n >= 0`是否成立，如果为`true`，则返回`n`，否则返回`-n`。这实际上是一个求绝对值的表达式。

注意到三元运算`b ? x : y`会首先计算`b`，如果`b`为`true`，则只计算`x`，否则，只计算`y`。此外，`x`和`y`的类型必须相同，因为返回值不是`boolean`，而是`x`和`y`之一。

注意，`?:` 运算符的优先级只比赋值运算符高，比其他运算符都低，所以一般不用把操作数放在括号里。不过，很多程序员觉得，把第一个操作数放在括号里，条件表达式更易读。的确，毕竟 if 语句的条件表达式都放在括号里。

### `instanceof`操作符

`instanceof` 操作符的左侧操作数是对象或数组，右侧操作数是引用类型的名称。

+ 如果对象或数组是指定类型的实例，计算结果为 true；否则，计算结果为 false。
+ 如果左侧操作数是 null，`instanceof` 操作符的计算结果始终为 false。
+ 如果 `instanceof` 表达式的计算结果为 true，意味着可以放心校正并把左侧操作数赋值给类型为右侧操作数的变量。

`instanceof` 操作符只能用于引用类型和对象，不能用于基本类型和值。`instanceof` 操作符的使用示例如下：

```java
// true：所有字符串都是String类的实例 
"string" instanceof String 
// true：字符串也是Object类的实例 
"" instanceof Object 
// false：null不是任何类的实例 
null instanceof String 

Object o = new int[] {1,2,3}; 
o instanceof int[]   // true：这个数组是int数组 
o instanceof byte[]  // false：这个数组不是byte数组 
o instanceof Object  // true：所有数组都是Object类的实例 

// 使用instanceof确保能放心校正对象 
if (object instanceof Point) { 
   Point p = (Point) object; 
}
```

### 特殊运算符

Java 有六种语言结构，有时当成运算符，有时只当成基本句法的一部分。

**1、访问对象成员（`.`）**：对象由一些数据和处理这些数据的方法组成。对象的数据字段和方法称为这个对象的成员。点号运算符（`.`）用来访问这些成员。

+ 如果 `o` 是一个表达式，而且计算结果为对象引用，`f` 是这个对象的字段名称，那么，`o.f` 的计算结果是字段 `f` 中的值。
+ 如果 `m` 是一个方法的名称，那么，`o.m` 指向这个方法，而且能使用后面介绍的 `()` 运算符调用。

**2、访问数组中的元素（`[]`）**：数组是由编号的值组成的列表。数组中的每个元素都能使用各自的编号（或叫索引）引用。`[ ]` 运算符能指向数组中的单个元素。如果 `a` 是一个数组，`i` 是能计算为 int 类型的表达式，那么，`a[i]` 指向 a 中的一个元素。这个运算符不像其他处理整数的运算符，它强制要求数组的索引必须是 int 类型或者取值范围更窄的类型。

**3、调用方法（`()`）**：方法是一些有名称的 Java 代码，在这个名称的后面加上括号，并在括号中放零个或多个以逗号分隔的表达式，可以运行（或叫调用）方法。括号中的表达式计算得到的值是方法的参数。方法会处理这些参数，有时还会返回一个值，这个值是方法调用表达式的返回值。

+ 如果 `o.m` 是一个没有参数的方法，那么这个方法可以使用 `o.m()` 调用。
+ 假设这个方法有三个参数，那么可以使用表达式 `o.m(x,y,z)` 调用。Java 解释器调用方法之前，会先计算传入的参数。这些表达式始终从左至右计算（如果参数有副作用，就能体现顺序的重要性）。

**4、lambda表达式**（`->`）：lambda 表达式是一些匿名的 Java 可执行代码，其实就是方法的主体，由方法的参数列表（零个或多个以逗号分隔的表达式，放在括号中）、lambda 箭头运算符和一段 Java 代码组成。如果代码段只有一个语句，可以省略标识块边界常用的花括号。

**5、创建对象（`new`）**：在 Java 中，对象和数组使用 new 运算符创建。运算符后面跟着想创建的对象类型，括号中还可以指定一些传给对象构造方法的参数。构造方法是一种特殊的代码块，用于实例化新建的对象。创建对象的句法和调用方法的句法类似。例如：

```java
new ArrayList(); 
new Point(1,2)
```

**6、类型转换或校正（`()`）**：前面已经介绍过，括号还可以当成执行缩小类型转换（或叫校正）的运算符。这个运算符的第一个操作数是想转换的类型，放在括号里；第二个操作数是要转换的值，跟在括号后面。例如：

```java
(byte) 28           // 把整数字面量校正成byte类型 
(int) (x + 3.14f)   // 把浮点数之和校正成整数 
(String)h.get(k)    // 把泛型对象校正成字符串
```

### 其他运算

#### 类型自动提升与强制转型

在运算过程中，如果参与运算的两个数类型不一致，那么计算结果为较大类型的整型。例如，`short`和`int`计算，结果总是`int`，原因是`short`首先自动被转型为`int`：

```Java
public class Main {
    public static void main(String[] args) {
        short s = 1234;
        int i = 123456;
        int x = s + i; // s自动转型为int
        short y = s + i; // 编译错误!
    }
}
```

也可以将结果强制转型，即将大范围的整数转型为小范围的整数。强制转型使用`(类型)`，例如，将`int`强制转型为`short`：

```Java
int i = 12345;
short s = (short) i; // 12345
```

要注意，超出范围的强制转型会得到错误的结果，原因是转型时，`int`的两个高位字节直接被扔掉，仅保留了低位的两个字节：

```Java
public class Main {
    public static void main(String[] args) {
        int i1 = 1234567;
        short s1 = (short) i1; // -10617
        System.out.println(s1);
        int i2 = 12345678;
        short s2 = (short) i2; // 24910
        System.out.println(s2);
    }
}
```

 因此，强制转型的结果很可能是错的。

#### 浮点数的运算

 浮点数运算和整数运算相比，只能进行加减乘除这些数值计算，不能做位运算和移位运算。

在计算机中，浮点数虽然表示的范围大，但是，浮点数有个非常重要的特点，就是浮点数常常无法精确表示。

举个栗子：

浮点数`0.1`在计算机中就无法精确表示，因为十进制的`0.1`换算成二进制是一个无限循环小数，很显然，无论使用`float`还是`double`，都只能存储一个`0.1`的近似值。但是，`0.5`这个浮点数又可以精确地表示。

因为浮点数常常无法精确表示，因此，浮点数运算会产生误差：

```Java
public class Main {
    public static void main(String[] args) {
        double x = 1.0 / 10;
        double y = 1 - 9.0 / 10;
        // 观察x和y是否相等:
        System.out.println(x);
        System.out.println(y);
    }
}
```

由于浮点数存在运算误差，所以比较两个浮点数是否相等常常会出现错误的结果。正确的比较方法是判断两个浮点数之差的绝对值是否小于一个很小的数：

```Java
// 比较x和y是否相等，先计算其差的绝对值:
double r = Math.abs(x - y);
// 再判断绝对值是否足够小:
if (r < 0.00001) {
    // 可以认为相等
} else {
    // 不相等
}
```

浮点数在内存的表示方法和整数比更加复杂。Java的浮点数完全遵循IEEE-754标准，这也是绝大多数计算机平台都支持的浮点数标准表示方法。

#### 赋值与别名

```java
public class Assignment {
    public static void main(String[] args) {
        ObjectAssignment();
        System.out.println("---------------------");
        MethodAssignment();
    }
    static void ObjectAssignment(){
        Number n1 = new Number();
        Number n2 = new Number();
        n1.i = 9;
        n2.i = 47;
        System.out.println("n1.i = " + n1.i+"\t"+"n2.i = " + n2.i);
        //n1.i = 9 n2.i = 47
        n1 = n2;
        System.out.println("n1.i = " + n1.i+"\t"+"n2.i = " + n2.i);
        //n1.i = 47 n2.i = 47
        n1.i=27;
        System.out.println("n1.i = " + n1.i+"\t"+"n2.i = " + n2.i);
        //n1.i = 27 n2.i = 27
    }
    static void MethodAssignment(){
        Number n1 = new Number();
        Number n2 = new Number();
        n1.i = 9;
        n2.i = 47;
        System.out.println("n1.i = " + n1.i+"\t"+"n2.i = " + n2.i);
        //n1.i = 9 n2.i = 47
        n1.i = n2.i;
        System.out.println("n1.i = " + n1.i+"\t"+"n2.i = " + n2.i);
        //n1.i = 47 n2.i = 47
        n1.i=27;
        System.out.println("n1.i = " + n1.i+"\t"+"n2.i = " + n2.i);
        //n1.i = 27 n2.i = 47
    }
}

class Number {
    int i;
}

```

每个Number中的 i值都赋予了一个不同的值。随后，将 n2赋给 n1，而且 n1发生改变。在许多程序设计语言中，我们都希望n1和 n2任何时候都相互独立。看来改变n1的同时也改变了n2。这是由于无论n1还是 n2都包含了相同的句柄，它指向相同的对象（最初的句柄位于 n1内部，指向容纳了值9的一个对象。在赋值过程中，那个句柄实际已经丢失；它的对象会由“垃圾收集器”自动清除）。

这种特殊的现象通常也叫作“别名”，是 Java操作对象的一种基本方式。但假若不愿意在这种情况下出现别名，又该怎么操作呢？可放弃赋值，并写入下述代码： `n1.i = n2.i`这样便可保留两个独立的对象，而不是将 n1和 n2绑定到相同的对象。但您很快就会意识到，这样做会使对象内部的字段处理发生混乱，并与标准的面向对象设计准则相悖。

①**类型提升**

如果参与运算的两个数其中一个是整型，那么整型可以自动提升到浮点型：

```Java
public class Main {
    public static void main(String[] args) {
        int n = 5;
        double d = 1.2 + 24.0 / n; // 6.0
        System.out.println(d);
    }
}
```

需要特别注意，在一个复杂的四则运算中，两个整数的运算不会出现自动提升的情况。例如：

```Java
double d = 1.2 + 24 / 5; // 5.2
```

计算结果为`5.2`，原因是编译器计算`24 / 5`这个子表达式时，按两个整数进行运算，结果仍为整数`4`。

②**特殊值**

整数运算在除数为`0`时会报错，而浮点数运算在除数为`0`时，不会报错，但会返回几个特殊值：

+ `NaN`表示Not a Number
+ `Infinity`表示无穷大
+ `-Infinity`表示负无穷大

例如：

```Java
double d1 = 0.0 / 0; // NaN
double d2 = 1.0 / 0; // Infinity
double d3 = -1.0 / 0; // -Infinity
```

这三种特殊值在实际运算中很少碰到，我们只需要了解即可。

③**强制转型**

可以将浮点数强制转型为整数。在转型时，浮点数的小数部分会被丢掉。如果转型后超过了整型能表示的最大范围，将返回整型的最大值。例如：

```Java
int n1 = (int) 12.3; // 12
int n2 = (int) 12.7; // 12
int n2 = (int) -12.7; // -12
int n3 = (int) (12.7 + 0.5); // 13
int n4 = (int) 1.2e20; // 2147483647
```

如果要进行四舍五入，可以对浮点数加上0.5再强制转型：

```Java
public class Main {
    public static void main(String[] args) {
        double d = 2.6;
        int n = (int) (d + 0.5);
        System.out.println(n);
    }
}
```

## 字符串

和`char`类型不同，字符串类型`String`是引用类型，我们用双引号`"..."`表示字符串。一个字符串可以存储0个到任意个字符：

```Java
String s = ""; // 空字符串，包含0个字符
String s1 = "A"; // 包含一个字符
String s2 = "ABC"; // 包含3个字符
String s3 = "中文 ABC"; // 包含6个字符，其中有一个空格
```

因为字符串使用双引号`"..."`表示开始和结束，那如果字符串本身恰好包含一个`"`字符怎么表示？例如，`"abc"xyz"`，编译器就无法判断中间的引号究竟是字符串的一部分还是表示字符串结束。这个时候，我们需要借助转义字符`\`：

```Java
String s = "abc\"xyz"; // 包含7个字符: a, b, c, ", x, y, z
```

因为`\`是转义字符，所以，两个`\\`表示一个`\`字符：

```Java
String s = "abc\\xyz"; // 包含7个字符: a, b, c, \, x, y, z
```

常见的转义字符包括：

+ `\"` 表示字符`"`
+ `\'` 表示字符`'`
+ `\\` 表示字符`\`
+ `\n` 表示换行符
+ `\r` 表示回车符
+ `\t` 表示Tab
+ `\u####` 表示一个Unicode编码的字符

例如：

```Java
String s = "ABC\n\u4e2d\u6587"; // 包含6个字符: A, B, C, 换行符, 中, 文
```

### 字符串连接

Java的编译器对字符串做了特殊照顾，可以使用`+`连接任意字符串和其他数据类型，这样极大地方便了字符串的处理。例如：

```Java
// 字符串连接
public static void main(String[] args) {
    String s1 = "Hello";
    String s2 = "world";
    String s = s1 + " " + s2 + "!";
    System.out.println(s);
}
/*输出结果
Hello world!
*/
```

如果用`+`连接字符串和其他数据类型，会将其他数据类型先自动转型为字符串，再连接：

```Java
// 字符串连接
public static void main(String[] args) {
    int age = 25;
    String s = "age is " + age;
    System.out.println(s);
}
/*输出结果
age is 25
*/
```

### 多行字符串

如果我们要表示多行字符串，使用+号连接会非常不方便：

```Java
String s = "first line \n"
         + "second line \n"
         + "end";
```

从Java 13开始，字符串可以用`"""..."""`表示多行字符串（Text Blocks）了。举个例子：

```Java
// 多行字符串
public class Main {
    public static void main(String[] args) {
        String s = """
                   SELECT * FROM
                     users
                   WHERE id > 100
                   ORDER BY name DESC
                   """;
        System.out.println(s);
    }
}
```

上述多行字符串实际上是5行，在最后一个`DESC`后面还有一个`\n`。如果我们不想在字符串末尾加一个`\n`，就需要这么写：

```Java
String s = """
           SELECT * FROM
             users
           WHERE id > 100
           ORDER BY name DESC""";
```

还需要注意到，多行字符串前面共同的空格会被去掉，即：

```Java
String s = """
...........SELECT * FROM
...........  users
...........WHERE id > 100
...........ORDER BY name DESC
...........""";
```

用`.`标注的空格都会被去掉。

如果多行字符串的排版不规则，那么，去掉的空格就会变成这样：

```Java
String s = """
.........  SELECT * FROM
.........    users
.........WHERE id > 100
.........  ORDER BY name DESC
.........  """;
```

即总是以最短的行首空格为基准。

最后，由于多行字符串是作为Java 13的预览特性（Preview Language Features）实现的，编译的时候，我们还需要给编译器加上参数：

```Java
javac --source 13 --enable-preview Main.java
```

### 不可变特性

Java的字符串除了是一个引用类型外，还有个重要特点，就是字符串不可变。

```Java
// 字符串不可变
public class Main {
    public static void main(String[] args) {
        String s = "hello";
        System.out.println(s); // 输出 hello
        s = "world";
        System.out.println(s); // 输出 world
    }
}
```

观察执行结果，难道字符串`s`变了吗？其实变的不是字符串，而是变量`s`的“指向”。

执行`String s = "hello";`时，JVM虚拟机先创建字符串`"hello"`，然后，把字符串变量`s`指向它：

```ascii
      s
      │
      ▼
┌───┬───────────┬───┐
│   │  "hello"  │   │
└───┴───────────┴───┘
```

紧接着，执行`s = "world";`时，JVM虚拟机先创建字符串`"world"`，然后，把字符串变量`s`指向它：

```ascii
      s ──────────────┐
                      │
                      ▼
┌───┬───────────┬───┬───────────┬───┐
│   │  "hello"  │   │  "world"  │   │
└───┴───────────┴───┴───────────┴───┘
```

原来的字符串`"hello"`还在，只是我们无法通过变量`s`访问它而已。因此，字符串的不可变是指字符串内容不可变。

理解了引用类型的“指向”后，试解释下面的代码输出：

```Java
// 字符串不可变
public class Main {
    public static void main(String[] args) {
        String s = "hello";
        String t = s;
        s = "world";
        System.out.println(t); // t是"hello"还是"world"?
    }
}
```

### 空值null

引用类型的变量可以指向一个空值`null`，它表示不存在，即该变量不指向任何对象。例如：

```Java
String s1 = null; // s1是null
String s2; // 没有赋初值值，s2也是null
String s3 = s1; // s3也是null
String s4 = ""; // s4指向空字符串，不是null
```

注意要区分空值`null`和空字符串`""`，空字符串是一个有效的字符串对象，它不等于`null`。

### 类型转换

字符串的两个主要用途分别是将用户从键盘输入的内容转换成相应数据类型的值以及将各种数据类型的值转化成能够在屏幕上显示的内容。Java 的 String 类型为这些操作内置了相应的方法，而且 Integer 和 Double 库还包含了分别和 String 类型相互转化的静态方法

```java
public static void main(String[] args) {
    String strings = "123";
    int number = 123;
    System.out.println("Integer.parseInt(strings) = " + Integer.parseInt(strings));
    System.out.println("Integer.toString(number) = " + Integer.toString(number));
}
//将字符串strings转换为整数
//Integer.parseInt(strings) = 123
//将整数number转换为字符串
//Integer.toString(number) = 123
```

## 输入与输出

## 控制流

语句是 Java 语言中可执行代码的基本单位，表达程序员的某个意图。和表达式不同，Java语句没有返回值。语句一般包含表达式和运算符（尤其是赋值运算符），执行的目的往往是为了它们的副作用。

Java 定义的很多语句是流程控制语句，例如条件语句和循环语句，它们通过合理的方式改变默认的线性执行顺序。

| 语 句        | 作  用       | 句  法                                                       |
| ------------ | ------------ | ------------------------------------------------------------ |
| 表达式       | 副作用       | `var = expr; expr++; method(); new Type();`                  |
| 复合语句     | 语句组       | `{ statements }`                                             |
| 空语句       | 无作用       | `;`                                                          |
| 标注         | 为语句命名   | `label: statement`                                           |
| 变量         | 声明变量     | `[final] type name[=value][,name[=value]] ...;`              |
| if           | 条件判断     | `if (expr) statement[ else statement]`                       |
| switch       | 条件判断     | `switch (expr) { [ case expr : statements ] ... [ default: statements ] }` |
| while        | 循环         | `while (expr) statement`                                     |
| do           | 循环         | `do statement while (expr);`                                 |
| for          | 简单循环     | `for (init; test; increment) statement`                      |
| 遍历         | 迭代集合     | `for (variable : iterable) statement`                        |
| break        | 退出块       | `break [label];`                                             |
| continue     | 重新开始循环 | `continue [label];`                                          |
| return       | 结束方法     | `return [expr];`                                             |
| synchronized | 临界区       | `synchronized (expr) {statements}`                           |
| throw        | 抛出异常     | `throw expr;`                                                |
| try          | 处理异常     | `try {statements}[ catch (type name) { statements } ] ... [ finally { statements } ]` |
| assert       | 验证不变式   | `assert invariant[ :error];`                                 |

### 表达式语句

本章前面已经说过，某些 Java 表达式有副作用。也就是说，这些表达式不仅能计算得到的一个值，还能以某种方式改变程序的状态。只要表达式有副作用，在表达式后面加上分号就能作为语句使用。合法的表达式语句有赋值、递增和递减、方法调用以及对象创建。例如：

```java
a = 1;                              // 赋值 
x *= 2;                             // 带运算的赋值 
i++;                                // 后递增 
--c;                                // 前递减 
System.out.println("statement");    // 方法调用
```

### 复合语句

复合语句是一些放在花括号里的语句，语句的数量和类型不限。Java 句法规定可以使用语句的地方都可以使用复合语句：

```java
for(int i = 0; i < 10; i++) { 
   a[i]++;           // 这个循环体是一个复合语句 
   b[i]--;           // 包括两个表达式语句 
}                    // 放在花括号里
```

### 空语句

在 Java 中，空语句使用一个分号表示。空语句什么也不做，不过这种句法偶尔有用。例如，在 for 循环中可以使用空语句表明循环体为空：

```java
for(int i = 0; i < 10; a[i++]++)  // 递增数组元素 
     /* empty */;                 // 循环体是空语句
```

### 标注语句

标注语句就是有名称的语句。命名方法是，在语句前加上一个标识符和一个冒号。`break`和 `continue` 语句会用到标注。例如：

```java
rowLoop: for(int r = 0; r < rows.length; r++) {        // 一个标注循环 
   colLoop: for(int c = 0; c < columns.length; c++) {  // 另一个 
     break rowLoop;                                    // 使用标注 
   } 
}
```

### 局部变量声明语句

局部变量经常直接称为变量，是值存储位置的符号名称，在方法和复合语句中定义。所有变量在使用之前必须先声明，声明变量的方法是使用声明语句。Java 是静态类型语言，声明变量时要指定变量的类型，而且只有这种类型的值才能存储在这个变量中。变量声明语句最简单的形式只需指定变量的类型和名称：

```java
int counter; 
String s;
```

声明变量时还可以包含一个初始化表达式，用于指定变量的初始值。例如：

```java
int i = 0; 
String s = readLine(); 
int[] data = {x+1, x+2, x+3}; // 稍后会介绍数组初始化表达式
```

Java 编译器不允许使用未初始化的局部变量，所以，方便起见，通常会在一个语句中同时声明和初始化变量。初始化表达式不必是编译器能计算得到结果的字面量或常量表达式，也可以是程序运行时能计算出结果的任意复杂表达式。一个变量声明语句可以声明和初始化多个变量，但是所有变量必须是同一类型。变量名称和可选的初始化表达式使用逗号分隔：

```java
int i, j, k;   
float x = 1.0, y = 1.0; 
String question = "Really Quit?", response;
```

变量声明语句可以以 `final` 关键字开头。这个修饰符表明，为变量指定初始值之后，其值就不能改变了：

在 Java 代码的任何地方都能使用变量声明语句，而不局限于只能在方法和代码块的开头使用。局部变量声明还可以集成到 for 循环的初始化部分里。

```java
void method() {           // 定义一个方法 
   int i = 0;             // 声明变量i 
   while (i < 10) {       // 在这个作用域里可以使用i 
     int j = 0;           // 声明变量j；j的作用域从这里开始 
     i++;                 // 在这个作用域里可以使用i；递增i 
   }                      // 在这个作用域里不能使用j了 
   System.out.println(i); // 在这个作用域里仍能使用i 
}                         // i的作用域在这结束
```

### `if`/`else`语句

if 语句是基本的控制语句，允许 Java 作出判断，或者更准确地说，根据条件决定执行哪些语句。

+ 如果表达式的计算结果为 true，解释器会执行关联的语句；
+ 如果表达式的计算结果为 false，解释器会跳过关联的语句。

`if`语句的基本语法是：

```java
if (条件) {
    // 条件满足时执行
}
```

根据`if`的计算结果（`true`还是`false`），JVM决定是否执行`if`语句块（即花括号{}包含的所有语句）。

让我们来看一个例子：

```Java
// 条件判断
public class Main {
    public static void main(String[] args) {
        int n = 70;
        if (n >= 60) {
            System.out.println("及格了");
        }
        System.out.println("END");
    }
}
```

当条件`n >= 60`计算结果为`true`时，`if`语句块被执行，将打印`"及格了"`，否则，`if`语句块将被跳过。修改`n`的值可以看到执行效果。

注意到`if`语句包含的块可以包含多条语句：

```Java
// 条件判断
public class Main {
    public static void main(String[] args) {
        int n = 70;
        if (n >= 60) {
            System.out.println("及格了");
            System.out.println("恭喜你");
        }
        System.out.println("END");
    }
}
```

当`if`语句块只有一行语句时，可以省略花括号{}：

```Java
// 条件判断
public class Main {
    public static void main(String[] args) {
        int n = 70;
        if (n >= 60)
            System.out.println("及格了");
        System.out.println("END");
    }
}
```

但是，省略花括号并不总是一个好主意。假设某个时候，突然想给`if`语句块增加一条语句时：

```Java
// 条件判断
public class Main {
    public static void main(String[] args) {
        int n = 50;
        if (n >= 60)
            System.out.println("及格了");
            System.out.println("恭喜你"); // 注意这条语句不是if语句块的一部分
        System.out.println("END");
    }
}
```

 由于使用缩进格式，很容易把两行语句都看成`if`语句的执行块，但实际上只有第一行语句是`if`的执行块。在使用git这些版本控制系统自动合并时更容易出问题，所以不推荐忽略花括号的写法。

---

`if`语句还可以编写一个`else { ... }`，当条件判断为`false`时，将执行`else`的语句块：

```Java
// 条件判断
public class Main {
    public static void main(String[] args) {
        int n = 70;
        if (n >= 60) {
            System.out.println("及格了");
        } else {
            System.out.println("挂科了");
        }
        System.out.println("END");
    }
}
```

修改上述代码`n`的值，观察`if`条件为`true`或`false`时，程序执行的语句块。

注意，`else`不是必须的。

还可以用多个`if ... else if ...`串联。例如：

```Java
// 条件判断
public class Main {
    public static void main(String[] args) {
        int n = 70;
        if (n >= 90) {
            System.out.println("优秀");
        } else if (n >= 60) {
            System.out.println("及格了");
        } else {
            System.out.println("挂科了");
        }
        System.out.println("END");
    }
}
```

串联的效果其实相当于：

```Java
if (n >= 90) {
    // n >= 90为true:
    System.out.println("优秀");
} else {
    // n >= 90为false:
    if (n >= 60) {
        // n >= 60为true:
        System.out.println("及格了");
    } else {
        // n >= 60为false:
        System.out.println("挂科了");
    }
}
```

在串联使用多个`if`时，要*特别注意*判断顺序。观察下面的代码：

```Java
// 条件判断
public class Main {
    public static void main(String[] args) {
        int n = 100;
        if (n >= 60) {
            System.out.println("及格了");
        } else if (n >= 90) {
            System.out.println("优秀");
        } else {
            System.out.println("挂科了");
        }
    }
}
```

执行发现，`n = 100`时，满足条件`n >= 90`，但输出的不是`"优秀"`，而是`"及格了"`，原因是`if`语句从上到下执行时，先判断`n >= 60`成功后，后续`else`不再执行，因此，`if (n >= 90)`没有机会执行了。

正确的方式是按照判断范围从大到小依次判断：

```Java
// 从大到小依次判断：
if (n >= 90) {
    // ...
} else if (n >= 60) {
    // ...
} else {
    // ...
}
```

或者改写成从小到大依次判断：

```Java
// 从小到大依次判断：
if (n < 60) {
    // ...
} else if (n < 90) {
    // ...
} else {
    // ...
}
```

使用`if`时，还要特别注意边界条件。例如：

```Java
// 条件判断
public class Main {
    public static void main(String[] args) {
        int n = 90;
        if (n > 90) {
            System.out.println("优秀");
        } else if (n >= 60) {
            System.out.println("及格了");
        } else {
            System.out.println("挂科了");
        }
    }
}

```

假设我们期望90分或更高为“优秀”，上述代码输出的却是“及格”，原因是`>`和`>=`效果是不同的。

前面讲过了浮点数在计算机中常常无法精确表示，并且计算可能出现误差，因此，判断浮点数相等用`==`判断不靠谱：

```Java
// 条件判断
public class Main {
    public static void main(String[] args) {
        double x = 1 - 9.0 / 10;
        if (x == 0.1) {
            System.out.println("x is 0.1");
        } else {
            System.out.println("x is NOT 0.1");
        }
    }
}
```

正确的方法是利用差值小于某个临界值来判断：

```Java
// 条件判断
public class Main {
    public static void main(String[] args) {
        double x = 1 - 9.0 / 10;
        if (Math.abs(x - 0.1) < 0.00001) {
            System.out.println("x is 0.1");
        } else {
            System.out.println("x is NOT 0.1");
        }
    }
}
```

判断引用类型相等

在Java中，判断值类型的变量是否相等，可以使用`==`运算符。但是，判断引用类型的变量是否相等，`==`表示“引用是否相等”，或者说，是否指向同一个对象。例如，下面的两个String类型，它们的内容是相同的，但是，分别指向不同的对象，用`==`判断，结果为`false`：

```Java
// 条件判断
public class Main {
    public static void main(String[] args) {
        String s1 = "hello";
        String s2 = "HELLO".toLowerCase();
        System.out.println(s1);
        System.out.println(s2);
        if (s1 == s2) {
            System.out.println("s1 == s2");
        } else {
            System.out.println("s1 != s2");
        }
    }
}
```

要判断引用类型的变量内容是否相等，必须使用`equals()`方法：

```Java
// 条件判断
public class Main {
    public static void main(String[] args) {
        String s1 = "hello";
        String s2 = "HELLO".toLowerCase();
        System.out.println(s1);
        System.out.println(s2);
        if (s1.equals(s2)) {
            System.out.println("s1 equals s2");
        } else {
            System.out.println("s1 not equals s2");
        }
    }
}
```

注意：执行语句`s1.equals(s2)`时，如果变量`s1`为`null`，会报`NullPointerException`：

```Java
// 条件判断
public class Main {
    public static void main(String[] args) {
        String s1 = null;
        if (s1.equals("hello")) {
            System.out.println("hello");
        }
    }
}
```

要避免`NullPointerException`错误，可以利用短路运算符`&&`：

```Java
// 条件判断
public class Main {
    public static void main(String[] args) {
        String s1 = null;
        if (s1 != null && s1.equals("hello")) {
            System.out.println("hello");
        }
    }
}
```

 还可以把一定不是`null`的对象`"hello"`放到前面：例如：`if ("hello".equals(s)) { ... }`。

### `switch`多重选择

除了if语句外，还有一种条件判断，是根据某个表达式的结果，分别去执行不同的分支。

例如，在游戏中，让用户选择选项：

1. 单人模式
2. 多人模式
3. 退出游戏

这时，`switch`语句就派上用场了。

`switch`语句根据`switch (表达式)`计算的结果，跳转到匹配的`case`结果，然后继续执行后续语句，直到遇到`break`结束执行。

我们看一个例子：

```Java
// switch
public class Main {
    public static void main(String[] args) {
        int option = 1;
        switch (option) {
        case 1:
            System.out.println("Selected 1");
            break;
        case 2:
            System.out.println("Selected 2");
            break;
        case 3:
            System.out.println("Selected 3");
            break;
        }
    }
}
```

修改`option`的值分别为`1`、`2`、`3`，观察执行结果。

如果`option`的值没有匹配到任何`case`，例如`option = 99`，那么，`switch`语句不会执行任何语句。这时，可以给`switch`语句加一个`default`，当没有匹配到任何`case`时，执行`default`：

```Java
// switch
public class Main {
    public static void main(String[] args) {
        int option = 99;
        switch (option) {
        case 1:
            System.out.println("Selected 1");
            break;
        case 2:
            System.out.println("Selected 2");
            break;
        case 3:
            System.out.println("Selected 3");
            break;
        default:
            System.out.println("Not selected");
            break;
        }
    }
}
```

如果把`switch`语句翻译成`if`语句，那么上述的代码相当于：

```Java
if (option == 1) {
    System.out.println("Selected 1");
} else if (option == 2) {
    System.out.println("Selected 2");
} else if (option == 3) {
    System.out.println("Selected 3");
} else {
    System.out.println("Not selected");
}
```

对于多个`==`判断的情况，使用`switch`结构更加清晰。

同时注意，上述“翻译”只有在`switch`语句中对每个`case`正确编写了`break`语句才能对应得上。

使用`switch`时，注意`case`语句并没有花括号`{}`，而且，`case`语句具有“**穿透性**”，漏写`break`将导致意想不到的结果：

```Java
// switch
public class Main {
    public static void main(String[] args) {
        int option = 2;
        switch (option) {
        case 1:
            System.out.println("Selected 1");
        case 2:
            System.out.println("Selected 2");
        case 3:
            System.out.println("Selected 3");
        default:
            System.out.println("Not selected");
        }
    }
}
```

当`option = 2`时，将依次输出`"Selected 2"`、`"Selected 3"`、`"Not selected"`，原因是从匹配到`case 2`开始，后续语句将全部执行，直到遇到`break`语句。因此，任何时候都不要忘记写`break`。

如果有几个`case`语句执行的是同一组语句块，可以这么写：

```Java
// switch
public class Main {
    public static void main(String[] args) {
        int option = 2;
        switch (option) {
        case 1:
            System.out.println("Selected 1");
            break;
        case 2:
        case 3:
            System.out.println("Selected 2, 3");
            break;
        default:
            System.out.println("Not selected");
            break;
        }
    }
}
```

使用`switch`语句时，只要保证有`break`，`case`的顺序不影响程序逻辑：

```Java
switch (option) {
case 3:
    ...
    break;
case 2:
    ...
    break;
case 1:
    ...
    break;
}
```

但是仍然建议按照自然顺序排列，便于阅读。

`switch`语句还可以匹配字符串。字符串匹配时，是比较“内容相等”。例如：

```Java
// switch
public class Main {
    public static void main(String[] args) {
        String fruit = "apple";
        switch (fruit) {
        case "apple":
            System.out.println("Selected apple");
            break;
        case "pear":
            System.out.println("Selected pear");
            break;
        case "mango":
            System.out.println("Selected mango");
            break;
        default:
            System.out.println("No fruit selected");
            break;
        }
    }
}
```

`switch`语句还可以使用枚举类型，枚举类型我们在后面讲解。

#### `switch`表达式

使用`switch`时，如果遗漏了`break`，就会造成严重的逻辑错误，而且不易在源代码中发现错误。从Java 12开始，`switch`语句升级为更简洁的表达式语法，使用类似模式匹配（Pattern Matching）的方法，保证只有一种路径会被执行，并且不需要`break`语句：

```Java
// switch
public class Main {
    public static void main(String[] args) {
        String fruit = "apple";
        switch (fruit) {
        case "apple" -> System.out.println("Selected apple");
        case "pear" -> System.out.println("Selected pear");
        case "mango" -> {
            System.out.println("Selected mango");
            System.out.println("Good choice!");
        }
        default -> System.out.println("No fruit selected");
        }
    }
}
```

注意新语法使用`->`，如果有多条语句，需要用`{}`括起来。不要写`break`语句，因为新语法只会执行匹配的语句，没有穿透效应。

很多时候，我们还可能用`switch`语句给某个变量赋值。例如：

```Java
int opt;
switch (fruit) {
case "apple":
    opt = 1;
    break;
case "pear":
case "mango":
    opt = 2;
    break;
default:
    opt = 0;
    break;
}
```

使用新的`switch`语法，不但不需要`break`，还可以直接返回值。把上面的代码改写如下：

```Java
// switch
public class Main {
    public static void main(String[] args) {
        String fruit = "apple";
        int opt = switch (fruit) {
            case "apple" -> 1;
            case "pear", "mango" -> 2;
            default -> 0;
        }; // 注意赋值语句要以;结束
        System.out.println("opt = " + opt);
    }
}
```

这样可以获得更简洁的代码。

#### `yield`

大多数时候，在`switch`表达式内部，我们会返回简单的值。

但是，如果需要复杂的语句，我们也可以写很多语句，放到`{...}`里，然后，用`yield`返回一个值作为`switch`语句的返回值：

```Java
// yield
public class Main {
    public static void main(String[] args) {
        String fruit = "orange";
        int opt = switch (fruit) {
            case "apple" -> 1;
            case "pear", "mango" -> 2;
            default -> {
                int code = fruit.hashCode();
                yield code; // switch语句返回值
            }
        };
        System.out.println("opt = " + opt);
    }
}
```

由于`switch`表达式是作为Java 13的预览特性（Preview Language Features）实现的，编译的时候，我们还需要给编译器加上参数：

```shell
> javac --source 13 --enable-preview Main.java
```

这样才能正常编译。

### `while`循环

循环语句就是让计算机根据条件做循环计算，在条件满足时继续循环，条件不满足时退出循环。

例如，计算从1到100的和：

除了用数列公式外，完全可以让计算机做100次循环累加。因为计算机的特点是计算速度非常快，我们让计算机循环一亿次也用不到1秒，所以很多计算的任务，人去算是算不了的，但是计算机算，使用循环这种简单粗暴的方法就可以快速得到结果。

我们先看Java提供的`while`条件循环。它的基本用法是：

```java
while (条件表达式) {
    循环语句
}
// 继续执行后续代码
```

`while`循环在每次循环开始前，首先判断条件是否成立。如果计算结果为`true`，就把循环体内的语句执行一遍，如果计算结果为`false`，那就直接跳到`while`循环的末尾，继续往下执行。

我们用while循环来累加1到100，可以这么写：

```Java
// while
public class Main {
    public static void main(String[] args) {
        int sum = 0; // 累加的和，初始化为0
        int n = 1;
        while (n <= 100) { // 循环条件是n <= 100
            sum = sum + n; // 把n累加到sum中
            n ++; // n自身加1
        }
        System.out.println(sum); // 5050
    }
}
```

注意到`while`循环是先判断循环条件，再循环，因此，有可能一次循环都不做。

对于循环条件判断，以及自增变量的处理，要特别注意边界条件。思考一下下面的代码为何没有获得正确结果：

```Java
// while
public class Main {
    public static void main(String[] args) {
        int sum = 0;
        int n = 0;
        while (n <= 100) {
            n ++;
            sum = sum + n;
        }
        System.out.println(sum);
    }
}
```

如果循环条件永远满足，那这个循环就变成了死循环。死循环将导致100%的CPU占用，用户会感觉电脑运行缓慢，所以要避免编写死循环代码。

如果循环条件的逻辑写得有问题，也会造成意料之外的结果：

```Java
// while
public class Main {
    public static void main(String[] args) {
        int sum = 0;
        int n = 1;
        while (n > 0) {
            sum = sum + n;
            n ++;
        }
        System.out.println(n); // -2147483648
        System.out.println(sum);
    }
}
```

 表面上看，上面的`while`循环是一个死循环，但是，Java的`int`类型有最大值，达到最大值后，再加1会变成负数，结果，意外退出了`while`循环。

#### `do while`循环

在Java中，`while`循环是先判断循环条件，再执行循环。而另一种`do while`循环则是先执行循环，再判断条件，条件满足时继续循环，条件不满足时退出。它的用法是：

```java
do {
    执行循环语句
} while (条件表达式);
```

可见，`do while`循环会至少循环一次。

我们把对1到100的求和用`do while`循环改写一下：

```Java
// do-while
public class Main {
    public static void main(String[] args) {
        int sum = 0;
        int n = 1;
        do {
            sum = sum + n;
            n ++;
        } while (n <= 100);
        System.out.println(sum);
    }
}
```

 使用`do while`循环时，同样要注意循环条件的判断。

### `for`循环

除了`while`和`do while`循环，Java使用最广泛的是`for`循环。

`for`循环的功能非常强大，它使用计数器实现循环。`for`循环会先初始化计数器，然后，在每次循环前检测循环条件，在每次循环后更新计数器。计数器变量通常命名为`i`。

我们把1到100求和用`for`循环改写一下：

```Java
// for
public class Main {
    public static void main(String[] args) {
        int sum = 0;
        for (int i=1; i<=100; i++) {
            sum = sum + i;
        }
        System.out.println(sum);
    }
}
```

在`for`循环执行前，会先执行初始化语句`int i=1`，它定义了计数器变量`i`并赋初始值为`1`，然后，循环前先检查循环条件`i<=100`，循环后自动执行`i++`，因此，和`while`循环相比，`for`循环把更新计数器的代码统一放到了一起。在`for`循环的循环体内部，不需要去更新变量`i`。

因此，`for`循环的用法是：

```java
for (初始条件; 循环检测条件; 循环后更新计数器) {
    // 执行语句
}
```

如果我们要对一个整型数组的所有元素求和，可以用`for`循环实现：

```Java
// for
public class Main {
    public static void main(String[] args) {
        int[] ns = { 1, 4, 9, 16, 25 };
        int sum = 0;
        for (int i=0; i<ns.length; i++) {
            System.out.println("i = " + i + ", ns[i] = " + ns[i]);
            sum = sum + ns[i];
        }
        System.out.println("sum = " + sum);
    }
}
```

上面代码的循环条件是`i`。因为`ns`数组的长度是`5`，因此，当循环`5`次后，`i`的值被更新为`5`，就不满足循环条件，因此`for`循环结束。

 思考：如果把循环条件改为`i<=ns.length`，会出现什么问题？

注意`for`循环的初始化计数器总是会被执行，并且`for`循环也可能循环0次。

使用`for`循环时，千万不要在循环体内修改计数器！在循环体中修改计数器常常导致莫名其妙的逻辑错误。对于下面的代码：

```Java
// for
public class Main {
    public static void main(String[] args) {
        int[] ns = { 1, 4, 9, 16, 25 };
        for (int i=0; i<ns.length; i++) {
            System.out.println(ns[i]);
            i = i + 1;
        }
    }
}

```

虽然不会报错，但是，数组元素只打印了一半，原因是循环内部的`i = i + 1`导致了计数器变量每次循环实际上加了`2`（因为`for`循环还会自动执行`i++`）。因此，在`for`循环中，不要修改计数器的值。计数器的初始化、判断条件、每次循环后的更新条件统一放到`for()`语句中可以一目了然。

如果希望只访问索引为奇数的数组元素，应该把`for`循环改写为：

```Java
int[] ns = { 1, 4, 9, 16, 25 };
for (int i=0; i<ns.length; i=i+2) {
    System.out.println(ns[i]);
}
```

通过更新计数器的语句`i=i+2`就达到了这个效果，从而避免了在循环体内去修改变量`i`。

使用`for`循环时，计数器变量`i`要尽量定义在`for`循环中：

```Java
int[] ns = { 1, 4, 9, 16, 25 };
for (int i=0; i<ns.length; i++) {
    System.out.println(ns[i]);
}
// 无法访问i
int n = i; // compile error!
```

如果变量`i`定义在`for`循环外：

```Java
int[] ns = { 1, 4, 9, 16, 25 };
int i;
for (i=0; i<ns.length; i++) {
    System.out.println(ns[i]);
}
// 仍然可以使用i
int n = i;
```

那么，退出`for`循环后，变量`i`仍然可以被访问，这就破坏了变量应该把访问范围缩到最小的原则。

#### 灵活使用for循环

`for`循环还可以缺少初始化语句、循环条件和每次循环更新语句，例如：

```Java
// 不设置结束条件:
for (int i=0; ; i++) {
    ...
}
// 不设置结束条件和更新语句:
for (int i=0; ;) {
    ...
}
// 什么都不设置:
for (;;) {
    ...
}
```

通常不推荐这样写，但是，某些情况下，是可以省略`for`循环的某些语句的。

#### for each循环

`for`循环经常用来遍历数组，因为通过计数器可以根据索引来访问数组的每个元素：

```Java
int[] ns = { 1, 4, 9, 16, 25 };
for (int i=0; i<ns.length; i++) {
    System.out.println(ns[i]);
}
```

但是，很多时候，我们实际上真正想要访问的是数组每个元素的值。Java还提供了另一种`for each`循环，它可以更简单地遍历数组：

```Java
// for each
public class Main {
    public static void main(String[] args) {
        int[] ns = { 1, 4, 9, 16, 25 };
        for (int n : ns) {
            System.out.println(n);
        }
    }
}
```

和`for`循环相比，`for each`循环的变量n不再是计数器，而是直接对应到数组的每个元素。`for each`循环的写法也更简洁。但是，`for each`循环无法指定遍历顺序，也无法获取数组的索引。

除了数组外，`for each`循环能够遍历所有“可迭代”的数据类型，包括后面会介绍的`List`、`Map`等。

### `break`和`continue`

无论是`while`循环还是`for`循环，有两个特别的语句可以使用，就是`break`语句和`continue`语句。

#### `break`

在循环过程中，可以使用`break`语句跳出当前循环。我们来看一个例子：

```Java
// break
public class Main {
    public static void main(String[] args) {
        int sum = 0;
        for (int i=1; ; i++) {
            sum = sum + i;
            if (i == 100) {
                break;
            }
        }
        System.out.println(sum);
    }
}
```

使用`for`循环计算从1到100时，我们并没有在`for()`中设置循环退出的检测条件。但是，在循环内部，我们用`if`判断，如果`i==100`，就通过`break`退出循环。

因此，`break`语句通常都是配合`if`语句使用。要特别注意，`break`语句总是跳出自己所在的那一层循环。例如：

```Java
// break
public class Main {
    public static void main(String[] args) {
        for (int i=1; i<=10; i++) {
            System.out.println("i = " + i);
            for (int j=1; j<=10; j++) {
                System.out.println("j = " + j);
                if (j >= i) {
                    break;
                }
            }
            // break跳到这里
            System.out.println("breaked");
        }
    }
}
```

上面的代码是两个`for`循环嵌套。因为`break`语句位于内层的`for`循环，因此，它会跳出内层`for`循环，但不会跳出外层`for`循环。

#### `continue`

`break`会跳出当前循环，也就是整个循环都不会执行了。而`continue`则是提前结束本次循环，直接继续执行下次循环。我们看一个例子：

```Java
// continue
public class Main {
    public static void main(String[] args) {
        int sum = 0;
        for (int i=1; i<=10; i++) {
            System.out.println("begin i = " + i);
            if (i % 2 == 0) {
                continue; // continue语句会结束本次循环
            }
            sum = sum + i;
            System.out.println("end i = " + i);
        }
        System.out.println(sum); // 25
    }
}
```

注意观察`continue`语句的效果。当`i`为奇数时，完整地执行了整个循环，因此，会打印`begin i=1`和`end i=1`。在i为偶数时，`continue`语句会提前结束本次循环，因此，会打印`begin i=2`但不会打印`end i = 2`。

在多层嵌套的循环中，`continue`语句同样是结束本次自己所在的循环。

### `throw`语句

异常是一种信号，表明发生了某种异常状况或错误。

+ 抛出异常的目的是发出信号，表示有异常状况发生。
+ 捕获异常的目的是处理异常，使用必要的操作修复。

在 Java 中，throw 语句用于抛出异常：

```java
throw expression;
```

expression 的计算结果必须是一个异常对象，说明发生了什么异常或错误。稍后会详细介绍异常的种类，现在你只需知道，异常通过有点特殊的对象表示。下面是抛出异常的示例代码：

```java
public static double factorial(int x) {
    if (x < 0) {
        throw new IllegalArgumentException("x must be >= 0");
    }
    double fact;
    for (fact = 1.0; x > 1; fact *= x, x--) {
        System.out.print(x + ",");
    }
    System.out.println();
    return fact;
}
```

Java 解释器执行 throw 语句时，会立即停止常规的程序执行，开始寻找能捕获或处理异常的异常处理程序。异常处理程序使用 `try`/`catch`/`finally` 语句编写。

Java解释器先在当前代码块中查找异常处理程序，如果有，解释器会退出这个代码块，开始执行异常处理代码。异常处理程序执行完毕后，解释器会继续执行处理程序后的语句。

如果当前代码块中没有适当的异常处理程序，解释器会在外层代码块中寻找，直到找到为止。如果方法中没有能处理 `throw` 语句抛出的异常的异常处理程序，解释器会停止运行当前方法，返回调用这个方法的地方，开始在调用方法的代码块中寻找异常处理程序。

Java通过这种方式，通过方法的词法结构不断向上冒泡，顺着解释器的调用堆栈一直向上寻找。如果一直没有捕获异常，就会冒泡到程序的 `main()` 方法。如果在 `main()` 方法中也没有处理异常，Java 解释器会打印一个错误消息，还会打印一个堆栈跟踪，指明这个异常在哪里发生，然后退出。

### `assert`语句

`assert` 语句用来验证 Java 代码的设计假想。断言（assertion）由 `assert` 关键字和布尔表达式组成，程序员认为布尔表达式的计算结果始终应该为 true。默认情况下断言未启用，assert 语句什么作用也没有。

不过，可以启用断言，作为一种调试工具。启用后，`assert` 语句会计算表达式。如果表达式的计算结果确是 true，`assert` 语句什么也不做；如果计算结果是 false，断言失败，`assert` 语句抛出 `java.lang.AssertionError` 异常。

> 在 JDK 库之外，极少使用 assert 语句。用它测试大多数应用都不灵便，一般的开发者很少使用，不过有时用来现场调试复杂的多线程应用。

`assert` 语句可以包含可选的第二个表达式，使用冒号和第一个表达式分开。如果启用了断言，而且第一个表达式的计算结果为 false，那么第二个表达式的值会作为错误代码或错误消息传给 AssertionError() 构造方法。assert 语句的完整句法如下：

```java
assert assertion;
//或者
assert assertion : errorcode;
```

### `synchronized`语句

Java 一直支持多线程编程，但并发编程不容易，有很多难以捉摸的地方。具体而言，处理多线程时，经常必须避免多个线程同时修改同一个对象，以防对象的状态有冲突。Java 提供的 `synchronized` 语句可以帮助程序员，避免发生冲突。`synchronized` 语句的句法为：

```java
synchronized ( expression ) { 
   statements 
}
```

`expression` 表达式的计算结果必须是一个对象或数组。`statements` 是能导致破坏的代码块，必须放在花括号里。

执行语句块之前，Java 解释器先为 `expression` 计算得到的对象或数组获取一个排它锁（exclusive lock），直到语句块执行完毕后再释放。只要某个线程拥有对象的排它锁，其他线程就不能再获取这个锁。

在 Java 中，`synchronized` 关键字还可以作为方法的修饰符。应用于方法时，`synchronized`关键字指明整个方法都被锁定。如果 `synchronized` 关键字应用于类方法（静态方法），执行方法前，Java 会先为这个类获取一个排它锁。如果 `synchronized` 关键字应用于实例方法，Java 为类的实例获取一个排它锁。

### `try`/`catch`/`finally`语句

Java 有两种稍微不同的异常处理机制。经典形式是使用 `try`/`catch`/`finally` 语句。这个语句的 `try` 子句是可能抛出异常的代码块。`try` 代码块后面是零个或多个 `catch` 子句，每个子句用于处理特定类型的异常，而且能处理多个不同类型的异常。如果 `catch` 块要处理多个异常，使用 | 符号分隔各个不同的异常。`catch` 子句后面是一个可选的 `finally` 块，包含清理代码，不管 `try` 块中发生了什么，始终都会执行。

> `catch` 和 `finally` 子句都是可选的，但每个 `try` 块都必须有这两个子句中的一个。`try`、`catch` 和 `finally` 块都放在花括号里。花括号是句法必须的一部分，即使子句只包含一个语句也不能省略

#### `try`子句

`try` 子句的作用很简单，组建一段代码，其中有异常需要处理，或者因某种原因终止执行后需要使用特殊的代码清理。`try` 子句本身没什么用，异常处理和清理操作在 `catch` 和`finally` 子句中进行。

#### `catch`子句

`try` 块后面可以跟着零个或多个 `catch` 子句，指定处理各种异常的代码。每个 `catch` 子句只有一个参数（可以使用特殊的 `|` 句法指明 `catch` 块能处理多种异常类型），指定这个子句能处理的异常类型，以及一个名称，用来引用当前处理的异常对象。`catch` 块能处理的类型必须是 `Throwable` 的子类。

有异常抛出时，Java 解释器会寻找一个 `catch` 子句，它的参数要和异常对象的类型相同，或者是这个类型的子类。解释器会调用它找到的第一个这种 `catch` 子句。`catch` 块中的代码应该执行处理异常状况所需的任何操作。假如异常是 `java.io.FileNotFoundException`，此时或许要请求用户检查拼写，然后重试。

不是所有可能抛出的异常都要有一个 `catch` 子句处理，有些情况下，正确的处理方式是让异常向上冒泡，由调用方法捕获。还有些情况，例如表示程序错误的`NullPointerException` 异常，正确的处理方式或许是完全不捕获，随它冒泡，让 Java 解释器退出，打印堆栈跟踪和错误消息。

#### `finally`子句

`finnaly` 子句放在 `try` 子句后面，一般用来执行清理操作（例如关闭文件和网络连接）。`finally` 子句很有用，因为不管 `try` 块中的代码以何种方式结束执行，只要有代码执行，`finally` 子句中的代码就会执行。事实上，只有一种方法能让 `try` 子句退出而不执行`finally` 子句——调用 `System.exit()` 方法，让 Java 解释器停止运行。

正常情况下，执行到 `try` 块的末尾后会继续执行 `finally` 块，做必要的清理工作。如果因为 `return`、`continue` 或 `break` 语句而离开 `try` 块，会先执行 `finally` 块，然后再转向新的目标代码。

如果 `try` 块抛出了异常，而且有处理该异常的 `catch` 块，那么先执行 `catch` 块，然后在执行 `finally` 块。如果本地没有能处理该异常的 `catch` 块，先执行 `finally` 块，然后再向上冒泡到能处理该异常最近的 `catch` 子句。

如果 `finally` 块使用 `return`、`continue`、`break` 或 `throw` 语句，或者调用的方法抛出了异常，从而转移了控制权，那么待转移的控制权中止，改为执行新的控制权转移。例如，如果 `finally` 子句抛出了异常，这个异常会取代任何正在抛出的异常。如果 `finally` 子句使用了 `return` 语句，就算抛出的异常还没处理，方法也会正常返回。

`try` 和 `finally` 子句可以放在一起使用，不处理异常，也没有 `catch` 子句。 此时，`finally` 块只是负责清理的代码，不管 `try` 子句中有没有 `break`、`continue` 或 `return` 语句，都会执行。

### 处理资源的try语句

Java（从第 7 版起）提供了一种很有用的机制，能自动关闭需要清理的资源——处理资源的 `try` 语句（try-with-resources，TWR）。下面的示例展示了如何使用 `FileInputStream` 类打开文件（得到的对象需要清理）：

```java
try (InputStream is = new FileInputStream("/Users/ben/details.txt")) { 
  // ……处理这个文件 
}
```

这种新型 try 语句的参数都是需要清理的对象（这些对象必须实现 `AutoCloseable` 接口）。这些对象的作用域在 `try` 块中，不管 `try`块以何种方式退出，都会自动清理。开发者无需编写任何 `catch` 或 `finally` 块，Java 编译器会自动插入正确的清理代码。

## 数组和数组列表

数组是一种特殊的对象，保存零个或多个基本类型或引用类型的值。这些值是数组的元素，是通过所在位置或索引引用的无名变量。数组的类型通过元素的类型表示，数组中的所有元素必须都属于这个类型。

数组元素的编号**从零开始**，有效的索引范围是零到元素数量减一。例如，索引为 1 的元素，是数组中的第二个元素。数组中的元素数量是数组的长度。数组的长度在创建时指定，从此就**不能改变**。

数组中元素的类型可以是任何有效的 Java 类型，包括数组类型。也就是说，Java 支持由数组组成的数组，实现多维数组。Java 不支持其他语言中的矩阵式多维数组。

### 数组的类型

数组的类型和类一样，也是引用类型。数组的实例和类的实例一样，也是对象。和类不同的是，数组的类型不用定义，只需在元素类型后面加上一对中括号即可。例如，下述代码声明了三种不同类型的数组：

```java
byte b;                        // byte是基本类型 
byte[] arrayOfBytes;           // byte[]是由byte类型的值组成的数组 
byte[][] arrayOfArrayOfBytes;  // byte[][]是由byte[]类型的值组成的数组 
String[] points;               // String[]是由字符串组成的数组
```

数组的长度不是数组类型的一部分。例如，声明一个方法，并且期望传入恰好由四个 int 类型的值组成的数组，是不可能的。如果方法的参数类型是 `int[]`，调用时传入的数组可以包含任意个元素（包括零个）。

数组类型不是类，但数组实例是对象。这意味着，数组从 `java.lang.Object` 类继承了方法。数组实现了 `Cloneable` 接口，而且覆盖了 `clone()` 方法，确保数组始终能被复制，而且 `clone()` 方法从不抛出 `CloneNotSupportedException` 异常。数组还实现了 `Serializable` 接口，所以只要数组中元素的类型能被序列化，数组就能被序列化。而且，所有数组都有一个名为 `length` 的字段，这个字段的修饰符是 `public final int`，表示数组中元素的数量。

---

1、数组类型放大转换

因为数组扩展自 `Object` 类，而且实现了 `Cloneable` 和 `Serializable` 接口，所以任何数组类型都能放大转换成这三种类型中的任何一种。而且，特定的数组类型还能放大转换成其他数组类型。如果数组中的元素类型是引用类型 T，而且 T 能指定给类型 S，那么数组类型`T[]` 就能指定给数组类型 `S[]`。注意，基本类型的数组不能放大转换。例如，下述代码展示了合法的数组放大转换：

```java
String[] arrayOfStrings;      // 创建字符串数组 
int[][] arrayOfArraysOfInt;   // 创建int二维数组 
// String可以指定给Object， 
// 因此String[]可以指定给Object[] 
Object[] oa = arrayOfStrings; 
// String实现了Comparable接口 
// 因此String[]可以视作Comparable[] 
Comparable[] ca = arrayOfStrings; 
// int[]是Object类的对象，因此int[][]可以指定给Object[] 
Object[] oa2 = arrayOfArraysOfInt; 
// 所有数组都是可以复制和序列化的对象 
Object o = arrayOfStrings; 
Cloneable c = arrayOfArraysOfInt; 
Serializable s = arrayOfArraysOfInt[0];
```

因为数组类型可以放大转换成另一种数组类型，所以编译时和运行时数组的类型并不总是一样。

> 这种放大转换叫作“数组协变”（array covariance）。现代标准认为这是历史遗留的不合理功能，因为编译时和运行时得出的类型不一致。

把引用类型的值存储在数组元素中之前，编译器通常必须插入运行时检查，确保运行时这个值的类型和数组元素的类型匹配。如果运行时检查失败，会抛出 `ArrayStoreException`异常。

2、与C语言兼容的句法

如前所示，指定数组类型的方法是在元素类型后加上一对中括号。为了兼容 C 和 C++，Java 还支持一种声明变量的句法：中括号放在变量名后面，元素类型后面可以放也可以不放中括号。这种句法可用于局部变量，字段和方法的参数。例如：

```java
// 这行代码声明类型为int，int[]和int[][]的局部变量 
int justOne, arrayOfThem[], arrayOfArrays[][]; 

// 这三行代码声明的字段属于同一种数组类型 
public String[][] aas1;   // 推荐使用的Java句法 
public String aas2[][];   // C语言的句法 
public String[] aas3[];   // 令人困惑的混用句法 

// 这个方法签名包含两个类型相同的参数 
public static double dotProduct(double[] x, double y[]) { ... }
```

> 这种兼容句法极其少见，不要使用。

### 创建和初始化数组

在 Java 中，使用 new 关键字创建数组，就像创建对象一样。数组类型没有构造方法，但创建数组时要指定长度，在中括号里使用非负整数指定所需的数组大小：

```java
// 创建一个能保存1024个byte类型数据的新数组 
byte[] buffer = new byte[1024]; 
// 创建一个能保存50个字符串引用的数组 
String[] lines = new String[50];
```

使用这种句法创建的数组，每个元素都会自动初始化，初始值和类中的字段默认值相同：

+ boolean 类型元素的初始值是 false；
+ char 类型元素的初始值是 \u0000；
+ 整数元素的初始值是 0；
+ 浮点数元素的初始值是 0.0；
+ 引用类型元素的初始值是 null。

创建数组的表达式也能用来创建和初始化多维数组。这种句法稍微复杂一些。

**数组初始化程序**：若想在一个表达式中创建数组并初始化其中的元素，不要指定数组的长度，在方括号后面跟着一对花括号，在花括号里写入一些逗号分隔的表达式。当然了，每个表达式的返回值类型必须能指定给数组元素的类型。创建的数组长度和表达式的数量相等。这组表达式的最后一个后面可以加上逗号，但没必要这么做。例如：

```java
String[] greetings = new String[] { "Hello", "Hi", "Howdy" }; 
int[] smallPrimes = new int[] { 2, 3, 5, 7, 11, 13, 17, 19, };
```

注意，这种句法无需把数组赋值给变量就能创建、初始化和使用数组。某种意义上，这种创建数组的表达式相当于匿名数组字面量。下面是几个示例：

```java
// 调用一个方法，传入一个包含两个字符串的匿名数组字面量 
String response = askQuestion("Do you want to quit?", 
                               new String[] {"Yes", "No"}); 
// 调用另一个方法，传入匿名对象组成的匿名数组 
double d = computeAreaOfTriangle(new Point[] { new Point(1,2), 
                                               new Point(3,4), 
                                               new Point(3,2) });
```

如果数组初始化程序是变量声明的一部分，可以省略 new 关键字和元素类型，在花括号里列出所需的元素：

```java
String[] greetings = { "Hello", "Hi", "Howdy" }; 
int[] powersOfTwo = {1, 2, 4, 8, 16, 32, 64, 128};
```

数组字面量在程序运行时，而不是程序编译时，创建和初始化。例如下述数组字面量：

```java
int[] perfectNumbers = {6, 28};
```

编译得到的 Java 字节码和下面的代码相同：

```java
int[] perfectNumbers = new int[2]; 
perfectNumbers[0] = 6; 
perfectNumbers[1] = 28;
```

Java 在运行时初始化数组有个重要的推论：数组初始化程序中的表达式可能会在运行时计算，而且不一定非要使用编译时常量。例如：

```java
Point[] points = { circle1.getCenterPoint(), circle2.getCenterPoint() };
```

### 使用数组

创建数组后就可以开始使用了。包括访问元素的基本方法，以及常见的数组用法，例如迭代数组中的元素，复制数组或数组的一部分。

#### 访问数组中的元素

数组中的元素是变量。如果元素出现在表达式中，其计算结果是这个元素中保存的值。如果元素出现在赋值运算符的左边，会把一个新值保存到这个元素中。不过，元素和普通的变量不同，它没有名字，只有编号。数组中的元素使用方括号访问。假如 a 是一个表达式，其计算结果为一个数组引用，那么可以使用 `a[i]` 索引数组，并引用某个元素。其中，i 是整数字面量或计算结果为 int 类型值的表达式。例如：

```java
// 创建一个由两个字符串组成的数组 
String[] responses = new String[2];
responses[0] = "Yes";  // 设定数组的第一个元素 
responses[1] = "No";   // 设定数组的第二个元素 

// 读取这个数组中的元素 
System.out.println(question + " (" + responses[0] + "/" + 
                   responses[1] + " ): "); 
 
// 数组引用和数组索引都可以是复杂的表达式 
double datum = data.getMatrix()[data.row() * data.numColumns() + 
                   data.column()];
```

数组的索引表达式必须是 int 类型，或能放大转换成 int 的类型：byte、short，甚至是char。数组的索引显然不能是 boolean、float 或 double 类型。还记得吗，数组的 length字段是 int 类型，所以数组中的元素数量不能超过 `Integer.MAX_VALUE`。如果使用 long 类型的表达式索引数组，即便运行时表达式的返回值在 int 类型的取值范围内，也会导致编译出错。

#### 数组的边界

还记得吗？数组 a 的第一个元素是 `a[0]`，第二个元素是 `a[1]`，最后一个元素是 `a[a.length-1]`。

使用数组时常见的错误是索引太小（负数）或太大（大于或等于数组的长度）。在 C 或C++ 等语言中，如果访问起始索引之前或结尾索引之后的元素，会导致无法预料的行为，而且在不同的调用和不同的平台中有所不同。这种问题不一定会被捕获，如果没捕获，可能过一段时间才会发现。因为在 Java 中容易编写错误的索引代码，所以运行时每次访问数组都会做检查，确保得到能预料的结果。如果数组的索引太小或太大，Java 会立即抛出`ArrayIndexOutOfBoundsException` 异常。

#### 迭代数组

为了在数组上执行某种操作，经常要编写循环，迭代数组中的每个元素。这种操作通常使用 for 循环完成。例如，下述代码计算整数数组中的元素之和：

```java
int[] primes = { 2, 3, 5, 7, 11, 13, 17, 19, 23 }; 
int sumOfPrimes = 0; 
for(int i = 0; i < primes.length; i++) 
    sumOfPrimes += primes[i];
```

这种 for 循环结构很有特色，会经常见到。Java 还支持遍历句法，前面已经介绍过。上述求和代码可以改写成下述简洁的代码：

```java
for(int p : primes) sumOfPrimes += p;
```

#### 复制数组

所有数组类型都实现了 `Cloneable` 接口，任何数组都能调用 `clone()` 方法复制自己。注意，返回值必须校正成适当的数组类型。不过，在数组上调用 `clone()` 方法不会抛出`CloneNotSupportedException` 异常：

```java
int[] data = { 1, 2, 3 }; 
int[] copy = (int[]) data.clone();
```

`clone()` 方法执行的是浅复制。如果数组的元素是引用类型，那么只复制引用，而**不复制引用的对象**。因为这种复制是浅复制，所以任何数组都能被复制，就算元素类型没有实现`Cloneable` 接口也行。

不过，有时只想把一个现有数组中的元素复制到另一个现有数组中。`System.arraycopy()`方法的目的就是高效完成这种操作。你可以假定 Java 虚拟机实现会在底层硬件中使用高速块复制操作执行这个方法。

`arraycopy()` 方法的作用简单明了，但使用起来有些难度，因为要记住五个参数。

+ 第一个参数是想从中复制元素的源数组；
+ 第二个参数是源数组中起始元素的索引；
+ 第三个参数是目标数组；
+ 第四个参数是目标索引；
+ 第五个参数是要复制的元素数量。

就算重叠复制同一个数组，`arraycopy()` 方法也能正确运行。例如，把数组 a 中索引为 0 的  元素删除后，想把索引为 1 到 n 的元素向左移，把索引变成 0 到 n-1，可以这么做：

```java
System.arraycopy(a, 1, a, 0, n);
```

#### 数组的实用方法

`java.util.Arrays` 类中包含很多处理数组的静态实用方法。这些方法中大多数都高度重载，有针对各种基本类型数组的版本，也有针对对象数组的版本。排序和搜索数组时，`sort()`和 `binarySearch()` 方法特别有用。`equals()` 方法用于比较两个数组的内容。如果想把数组的内容转换成一个字符串，例如用于调试或记录日志，`Arrays.toString()` 方法很有用。Arrays 类中还包含能正确处理多维数组的方法，例如 `deepEquals()`、`deepHashCode()` 和`deepToString()`。

### 多维数组

前面已经见过，数组类型的写法是在元素类型后面加一对方括号。`char` 类型元素组成的数组是 `char[]` 类型，由 `char[]` 类型元素组成的数组是 `char[][]`类型。如果数组的元素也是数组，我们说这个数组是多维数组。要想使用多维数组，需要了解一些其他细节。假如想使用多维数组表示乘法表：

```java
int[][] products;     // 乘法表
```

每对方括号表示一个维度，所以这是个二维数组。若想访问这个二维数组中的某个 `int`元素，必须指定两个索引值，一个维度一个。假设这个数组确实被初始化成一个乘法表，那么元素中存储的 int 值就是两个索引的乘积。也就是说，`products[2][4]` 的值是 8，`products[3][7]` 的值是 21。创建多维数组要使用 new 关键字，而且要指定每个维度中数组的大小。例如：

```java
int[][] products = new int[10][10];
```

在某些语言中，会把这样的数组创建成包含 100 个 int 值的数组，但 Java 不会这样处理。这行代码会做三件事。

+ 声明一个名为 products 的变量，保存一个由 `int[]` 类型数组组成的数组。
+ 创建一个有 10 个元素的数组，保存 10 个 `int[]` 类型的数组。
+ 再创建 10 个数组，每个都由 10 个 `int` 类型的元素组成。然后把这 10 个新数组指定为前一步创建的数组的元素。这 10 个新数组中的每一个 int 类型元素的默认值都是 0。

换种方式说，前面的单行代码等效于下述代码：

```java
int[][] products = new int[10][];  // 保存10个int[]类型值的数组 
for(int i = 0; i < 10; i++)        // 循环10次…… 
    products[i] = new int[10];     // ……创建10个数组
```

new 关键字会自动执行这些额外的初始化操作。超过两个维度的数组也是一样：

```java
float[][][] globalTemperatureData = new float[360][180][100];
```

使用 new 关键字创建多维数组时，无需指定所有维度的大小，只要为最左边的几个维度指定大小就行。例如，下面两行代码都是合法的：

```java
float[][][] globalTemperatureData = new float[360][][]; 
float[][][] globalTemperatureData = new float[360][180][];
```

第一行代码创建一个一维数组，元素是 `float[][]` 类型。第二行代码创建一个二维数组，元素是 `float[]` 类型。不过，如果只为数组的部分维度指定大小，这些维度必须位于最左边。下述代码是不合法的：

```java
float[][][] globalTemperatureData = new float[360][][100]; // 错误！ 
float[][][] globalTemperatureData = new float[][180][100]; // 错误！
```

和一维数组一样，多维数组也能使用数组初始化程序初始化，使用嵌套的花括号把数组嵌套在数组中即可。例如，可以像下面这样声明、创建并初始化一个 5×5 乘法表：

```java
int[][] products = { {0, 0, 0, 0, 0}, 
                     {0, 1, 2, 3, 4}, 
                     {0, 2, 4, 6, 8}, 
                     {0, 3, 6, 9, 12}, 
                     {0, 4, 8, 12, 16} };
```

如果不想声明变量就使用多维数组，可以使用匿名初始化程序句法：

```java
boolean response = bilingualQuestion(question, new String[][] { 
                                                   { "Yes", "No" }, 
                                                   { "Oui", "Non" }});
```

使用 new 关键字创建多维数组时，往往最好只使用矩形数组，即每个维度的数组大小相同。

### 数组存储的弊端

+ 一旦初始化以后，其长度就不可修改。
+ 数组中提供的方法非常限，对于添加、删除、插入数据等操作，非常不便，同时数率不高
+ 获取数组中实际元素的个数的需求，数组没有现成的属性或方法可用
+ 数组存储数据的特点：序字、可重复。对于无序、不可重复的需求，不能满足。

## 引用类型

至此，我们已经介绍了数组、类和对象，接下来可以介绍更一般的引用类型了。类和数组是 Java 五种引用类型中的两种。本节不涉及任何引用类型的具体句法，而是说明引用类型的一般行为，还会说明引用类型和基本类型的区别。本节使用术语“对象”指代引用类型（包括数组）的值或实例。

### 引用类型与基本类型比较

引用类型和对象与基本类型和基本值有本质的区别。

+ 八种基本类型由 Java 语言定义，程序员不能定义新基本类型。引用类型由用户定义，因此有无限多个。例如，程序可以定义一个名为 Point 的类，然后使用这个新定义类型的对象存储和处理笛卡儿坐标系中的 (x, y) 点。
+ 基本类型表示单个值。引用类型是聚合类型（aggregate type），可以保存零个或多个基本值或对象。例如，我们假设的 `Point` 类可能存储了两个 `double` 类型的值，表示点的 x 和 y 坐标。`char[]` 和 `Point[]` 数组类型是聚合类型，因为它们保存一些 `char` 类型的基本值或 `Point` 对象。
+ 基本类型需要一到八个字节的内存空间。把基本值存储到变量中，或者传入方法时，计算机会复制表示这个值的字节。而对象基本上需要更多的内存。创建对象时会在堆（heap）中动态分配内存，存储这个对象；如果不再需要使用这个对象了，存储它的内存会被自动垃圾回收。

> 把对象赋值给变量或传入方法时，不会复制表示这个对象的内存，而是把这个内存的引用存储在变量中或传入方法。

在 Java 中，引用完全不透明，引用的表示方式由 Java 运行时的实现细节决定。如果你是C 程序员的话，完全可以把引用看作指针或内存地址。不过要记住，Java 程序无法使用任何方式处理引用。与 C 和 C++ 中的指针不同的是，引用不能转换成整数，也不能把整数转换成引用，而且不能递增或递减。C 和 C++ 程序员还要注意，Java 不支持求地址运算符 `&`，也不支持解除引用运算符 `*` 和 `->`。

### 处理对象和引用副本

下述代码处理 int 类型基本值：

```java
int x = 42; 
int y = x;
```

执行这两行代码后，变量 y 中保存了变量 x 中所存值的一个副本。在 Java 虚拟机内部，这个 32 位整数 42 有两个独立的副本。
现在，想象一下把这段代码中的基本类型换成引用类型后再运行会发生什么：

```java
Point p = new Point(1.0, 2.0); 
Point q = p;
```

运行这段代码后，变量 q 中保存了一份变量 p 中所存引用的一个副本。在虚拟机中，仍然只有一个 Point 对象的副本，但是这个对象的引用有两个副本——这一点有重要的含义。假设上面两行代码的后面是下述代码：

```java
System.out.println(p.x);  // 打印p的x坐标：1.0 
q.x = 13.0;               // 现在，修改q的x坐标 
System.out.println(p.x);  // 再次打印p.x，这次得到的值是13.0
```

因为变量 p 和 q 保存的引用指向同一个对象，所以两个变量都可以用来修改这个对象，而且一个变量中的改动在另一个变量中可见。数组也是一种对象，所以对数组来说也会发生同样的事，如下面的代码所示：

```java
// greet保存一个数组的引用 
char[] greet = { 'h','e','l','l','o' }; 
char[] cuss = greet;             // cuss保存的是同一个数组的引用 
cuss[4] = '!';                   // 使用引用修改一个元素 
System.out.println(greet);       // 打印“hell!”
```

把基本类型和引用类型的参数传入方法时也有类似的区别。假如有下面的方法：

```java
void changePrimitive(int x) { 
    while(x > 0) { 
        System.out.println(x--); 
    } 
}
```

调用这个方法时，会把实参的副本传给形参 x。在这个方法的代码中，x 是循环计数器，向零递减。因为 x 是基本类型，所以这个方法有这个值的私有副本——这是完全合理的做法。

可是，如果把这个方法的参数改为引用类型，会发生什么呢？

```java
void changeReference(Point p) { 
    while(p.x > 0) { 
        System.out.println(p.x--); 
    } 
}
```

调用这个方法时，传入的是一个 Point 对象引用的私有副本，然后使用这个引用修改对应的 Point 对象。例如，有下述代码：

```java
Point q = new Point(3.0, 4.5); // 一个x坐标为3的点 
changeReference(q);            // 打印3，2，1，而且修改了这个Point对象 
System.out.println(q.x);       // 现在，q的x坐标是0！
```

调用 `changeReference()` 方法时，传入的是变量 q 中所存引用的副本。现在，变量 q 和方法的形参 p 保存的引用指向同一个对象。这个方法可以使用它的引用修改对象的内容。但是要注意，这个方法不能修改变量 q 的内容。也就是说，这个方法可以随意修改引用的 Point 对象，但不能改变变量 q 引用这个对象这一事实。

### 比较对象

我们已经介绍了基本类型和引用类型在赋值给变量、传入方法和复制时的显著区别。这两种类型在相等性比较时也有区别。相等运算符（`==`）比较基本值时，只测试两个值是否一样（即每一位的值都完全相同）。而 `==` 比较引用类型时，比较的是引用而不是真正的对象。也就是说，`==` 测试两个引用是否指向同一个对象，而不测试两个对象的内容是否相同。例如：

```java
String letter = "o"; 
String s = "hello";              // 这两个String对象 
String t = "hell" + letter;      // 保存的文本完全一样 
if (s == t) System.out.println("equal"); // 但是，二者并不相等！ 
 
byte[] a = { 1, 2, 3 }; 
// 内容一样的副本 
byte[] b = (byte[]) a.clone(); 
if (a == b) System.out.println("equal"); // 但是，二者并不相等！
```

对引用类型来说，有两种相等：引用相等和对象相等。一定要把这两种相等区分开。其中一种方式是，使用“相同”（identical）表示引用相等，使用“相等”（equal）表示对象的内容一样。若想测试两个不同的对象是否相等，可以在一个对象上调用 `equals()` 方法，然后把另一个对象传入这个方法：

```java
String letter = "o"; 
String s = "hello";              // 这两个String对象 
String t = "hell" + letter;      // 保存的文本完全一样 
if (s.equals(t)) {               // equals()方法 
    System.out.println("equal"); // 证实了这一点 
}
```

所有对象都（从 Object 类）继承了 `equals()` 方法，但是默认的实现方式是使用 `==` 测试引用是否相同，而不测试内容是否相等。想比较对象是否相等的类可以自定义 `equals()` 方法。Point 类没自定义，但 String 类自定义了，如前面的例子所示。可以在数组上调用 `equals()`方法，但作用和使用 `==` 运算符一样，因为数组始终继承默认的 `equals()` 方法，比较引用而不是数组的内容。比较数组是否相等可以使用 `java.util.Arrays.equals()` 实用方法。

### 装包和拆包转换

基本类型和引用类型的表现完全不同。有时需要把基本值当成对象，为此，Java 平台为每一种基本类型都提供了包装类。Boolean、Byte、Short、Character、Integer、Long、Float和 Double 是不可变的最终类，每个实例只保存一个基本值。包装类一般在把基本值存储在集合中时使用，例如 `java.util.List`：

```java
// 创建一个List集合 
List numbers = new ArrayList(); 
// 存储一个包装类表示的基本值 
numbers.add(new Integer(-1)); 
// 取出这个基本值 
int i = ((Integer)numbers.get(0)).intValue();
```

Java 支持装包和拆包类型转换。装包转换**把一个基本值转换成对应的包装对象**，而拆包转换的作用相反。虽然可以通过校正显式指定装包和拆包转换，但没必要这么做，因为把值赋值给变量或传入方法时会自动执行这种转换。此外，如果把包装对象传给需要基本值的Java 运算符或语句，也会自动执行拆包转换。因为 Java 能自动执行装包和拆包转换，所以这种语言特性一般叫作自动装包（autoboxing）。

下面是一些自动装包和拆包转换的示例：

```java
Integer i = 0;   // 把int类型字面量0装包到Integer对象中 
Number n = 0.0f; // 把float类型字面量装包到Float对象中，然后放大转换成Number类型 
Integer i = 1;   // 这是装包转换 
int j = i;       // i在这里拆包 
i++;             // 拆包i，递增，再装包 
Integer k = i+2; // 拆包i，再装包两数之和 
i = null; 
j = i;           // 这次拆包抛出NullPointerException异常
```

自动装包也把集合处理变得更简单了。下面这个示例，使用 Java 的泛型限制列表和其他集合中能存储什么类型的值：

```java
List<Integer> numbers = new ArrayList<>(); // 创建一个由整数组成的列表 
numbers.add(-1);                           // 把int类型的值装包到Integer对象中 
int i = numbers.get(0);                    // 把Integer对象拆包成int类型
```

## 注释

注释是使用自然语言编写的文本，供某一程序的人类读者阅读。Java 编译器会忽略注释。Java 支持三种注释。

第一种是单行注释，以 `//` 字符开始，直到行尾结束。

```Java
// 这是注释...
```

第二种是多行注释，以 `/*` 字符开始，不管有多少行，直到 `*/` 字符结束，一般用于多行注释。这种注释不能嵌套，即 `/* */` 中不能再有 `/* */`。编写多行注释时，程序员经常使用额外的 `*` 字符，突出注释的内容。

```Java
/*
 * 这是注释
 * blablabla...
 * 这也是注释
 */
```

第三种注释是第二种的一个特例。如果注释以 `/**` 开头，会被当成特殊的文档注释。和普通的多行注释一样，文档注释也以 `*/` 结尾，而且不能嵌套。如果你编写了一个 Java 类，希望让其他程序员使用，可以直接在源码中嵌入关于这个类和其中每个方法的文档。名为 javadoc 的程序会提取这些文档，经过处理后生成这个类的在线文档。文档注释中可以包含 HTML 标签和 javadoc 能理解的其他句法。例如：

```Java
/**
 * 可以用来自动创建文档的注释
 *
 * @auther lanqilu
 */
public class Hello {
    public static void main(String[] args) {
        System.out.println("Hello, world!");
    }
}
```

这种特殊的多行注释需要写在类和方法的定义处，可以用于自动创建文档。

类文档标记

+ `@version 版本信息`
+ `@author 作者信息`

方法文档标记

+ `@param 参数名 说明`
+ `@return 说明`
+ `@exception 完整类名 说明`
+ `@deprecated`

Java程序对格式没有明确的要求，多几个空格或者回车不影响程序的正确性，但是我们要养成良好的编程习惯，注意遵守Java社区约定的编码格式。

## 方法

方法是有名称的 Java 语句序列，可被其他 Java 代码调用。调用方法时，可以传入零个或多个值，这些值叫**参数**。方法执行一些计算，还可以返回一个值。

### 定义方法

方法主体就是放在花括号里的任意语句序列。更有趣的是方法的**签名**（signature）， 签名指定下述内容：

+ 方法的名称；
+ 方法所用参数的数量、顺序、类型和名称；
+ 方法的返回值类型；
+ 方法能抛出的已检异常（签名还能列出未检异常，不过不是必需的）；
+ 提供方法额外信息的多个方法修饰符。

方法签名定义了调用方法之前需要知道的一切信息，是方法的规范，而且定义了方法的API。

+ 若想使用 Java 平台的在线 API 参考指南，需要知道如何阅读方法签名。
+ 若想编写Java 程序，需要知道如何定义自己的方法。

方法都以方法签名开头。方法签名的格式如下：

```java
modifiers type name ( paramlist ) [ throws exceptions ]
```

签名（方法规范）后面是方法主体（方法的实现），即放在花括号里的 Java 语句序列。

+ `modifiers` 是零个或多个特殊的修饰符关键字，之间使用空格分开。例如，声明方法时可以使用 `public` 和 `static` 修饰符。
+ `type` 指明方法返回值的类型。如果方法没有返回值，`type` 必须是 `void`。如果声明方法时指定了返回类型，就必须包含一个 `return` 语句，返回一个符合（或能转换为）所声明类型的值。
+ `name`，即方法名。方法名和变量名一样，也是 Java 标识符。定义多个同名方法叫方法重载（method overloading）。
+ 定义方法时，方法名后一定是方法的形参列表（parameters list），而且必须放在括号里。形参列表定义零个或多个传入方法的实参（argument）。如果有形参的话，每个形参都包含类型和名称，如果有多个形参，形参之间使用逗号分开。调用方法时，传入的实参值必须和该方法签名中定义的形参数量、类型和顺序匹配。传入的值不一定要和签名中指定的类型一样，但是必须能不经校正转换为对应的类型。
+ 方法签名的最后一部分是 `throws` 子句，列出方法能抛出的已检异常（checked exception）。已检异常是一系列异常类，必须在能抛出它们的方法中使用 `throws` 子句列出。
  + 如果方法使用 `throw` 语句抛出一个已检异常，或者调用的其他方法抛出一个没有捕获或处理的已检异常，声明这个方法时就必须指明能抛出这个异常。
  + 如果方法能抛出一个或多个已检异常，要在参数列表后面使用 `throws` 关键字指明能抛出的异常类。
  + 如果方法不会抛出异常，无需使用 `throws` 关键字。
  + 如果方法抛出的异常类型不止一个，要使用逗号分隔异常类的名称。

> 抽象方法没有实现部分，方法主体使用一个分号表示。
> 构造方法是一段类似方法的代码，用于初始化新建的对象。
> 方法签名中可能包含类型变量声明，这种方法叫泛型方法（generic method）。

下面是一些方法定义示例，都以签名开头，后面跟着方法主体：

```java
// 这个方法传入的是字符串数组，没有返回值 
// 所有Java程序的入口都是这个名称和签名 
public static void main(String[] args) { 
    if (args.length > 0) {
        System.out.println("Hello " + args[0]);
    }
    else {
        System.out.println("Hello world");
    }
} 
```

```java
// 这个方法传入两个double类型的参数，返回一个double类型的数字 
static double distanceFromOrigin(double x, double y) { 
     return Math.sqrt(x*x + y*y); 
} 
```

```java
// 这是抽象方法，没有主体 
// 注意，调用这个方法时可能会抛出异常 
protected abstract String readText(File f, String encoding) 
    throws FileNotFoundException, UnsupportedEncodingException;
```

和某些其他语言不同，Java 没有匿名方法。不过，Java 8 引入了 `lambda` 表达式，作用类似于匿名方法，但是 Java 运行时会自动把 `lambda` 表达式转换成适当的具名方法，

### 方法修饰符

方法的修饰符包含零个或多个修饰符关键字，例如 `public`、`static` 或 `abstract`。

#### `abstract`

使用 `abstract` 修饰的方法没有实现主体。组成普通方法主体的花括号和 Java 语句使用一个分号代替。如果类中有使用 `abstract` 修饰的方法，类本身也必须使用 `abstract` 声明。这种类不完整，不能实例化。

#### `final`

使用 `final` 修饰的方法不能被子类覆盖或隐藏，能获得普通方法无法得到的编译器优化。所有使用 `private` 修饰的方法都隐式添加了 `final` 修饰符；使用 `final` 声明的任何类，其中的所有方法也都隐式添加 `final` 修饰符。

#### `native`

`native` 修饰符表明方法的实现使用某种“本地”语言编写，例如 C 语言，并且开放给Java 程序使用。`native` 修饰的方法和 `abstract` 修饰的方法一样，没有主体：花括号使用一个分号代替。

> Java 刚出现时，使用 `native` 修饰方法有时是为了提高效率。现在几乎不需要这么做了。现在，使用 `native` 修饰方法的目的是，把 Java 代码集成到现有的 C 或 C++ 库中。`native` 修饰的方法和所在平台无关，如何把实现和方法声明所在的 Java 类链接起来，取决于 Java 虚拟机的实现方式。

#### `public`、`protected`、`private`

些访问修饰符指定方法是否能在定义它的类之外使用，或者能在何处使用。

#### `static`

使用 `static` 声明的方法是类方法，关联在类自己身上，而不是类的实例身上

#### `strictfp`

在这个很少使用的奇怪修饰符中，fp 的意思是“浮点”（floating point）。一般情况下，Java 会利用运行时所在平台的浮点硬件提供的可用扩展精度。添加这个关键字后，运行`strictfp` 修饰的方法时，Java 会严格遵守标准，而且就算结果不精确，也只使用 32 位或 64 位浮点数格式进行浮点运算。

#### `synchronized`

`synchronized` 修饰符的作用是实现线程安全的方法。线程调用 `synchronized` 修饰的方法之前，必须先为方法所在的类（针对 static 修饰的方法）或对应的类实例（针对没使用 static 修饰的方法）获取一个锁，避免两个线程同时执行该方法。

`synchronized` 修饰符是实现的细节（因为方法可以通过其他方式实现线程安全），不是方法规范或 API 的正式组成部分。好的文档应该明确说明方法是否线程安全，使用多线程程序时不能依赖于是否有 `synchronized` 关键字。

### 已检异常和未检异常

Java 的异常处理机制会区分两种不同的异常类型：已检异常和未检异常。

已检异常和未检异常之间的区别在于异常在什么情况下抛出。已检异常在明确的特定情况下抛出，经常是应用能部分或完全恢复的情况。

例如，某段代码要在多个可能的目录中寻找配置文件。如果试图打开的文件不在某个目录中，就会抛出 `FileNotFoundException` 异常。在这个例子中，我们想捕获这个异常，然后在文件可能出现的下一个位置继续尝试。也就是说，虽然文件不存在是异常状况，但可以从中恢复，这是意料之中的失败。

然而，在 Java 环境中有些失败是无法预料的，这些失败可能是由运行时条件或滥用库代码导致的。例如，无法正确预知 `OutOfMemoryError` 异常；又如，把无效的 null 传给使用对象或数组的方法，会抛出 `NullPointerException` 异常。

这些是未检异常。基本上任何方法在任何时候都可能抛出未检异常。这是 Java 环境中的墨菲定律：“会出错的事总会出错。”从未检异常中恢复，虽说不是不可能，但往往很难，因为完全不可预知。

若想区分已检异常和未检异常，记住两点：异常是 `Throwable` 对象，而且异常主要分为两类，通过 `Error` 和 `Exception` 子类标识。只要异常对象是 `Error` 类，就是未检异常。`Exception` 类还有一个子类 `RuntimeException`，`RuntimeException` 类的所有子类都属于未检异常。除此之外，都是已检异常。

处理已检异常

Java 为已检异常和未检异常制定了不同的规则。如果定义的方法会抛出已检异常，就必须在方法签名的 `throws` 子句中声明这个异常。Java 编译器会检查方法签名，确保的确声明了；如果没声明，会导致编译出错（所以才叫“已检异常”）。

就算自己从不抛出已检异常，有时也必须使用 `throws` 子句声明已检异常。如果方法中调用了会抛出已检异常的方法，要么加入异常处理代码处理这个异常，要么使用 `throws` 子句声明这个方法也能抛出这个异常。

例如，下述方法使用标准库中的 java.net 和 URL 类访问网页，尝试估算网页的大小。所用的方法和构造方法会抛出各种 `java.io.IOException` 异常对象，所以在 `throws` 子句中声明了：

```java
public static estimateHomepageSize(String host) throws IOException { 
    URL url = new URL("htp://"+ host +"/"); 
    try (InputStream in = url.openStream()) { 
        return in.available(); 
    } 
}
```

其实，上述代码有个问题：协议名拼写错了——没有名为 htp:// 的协议。所以，`estimate-HomepageSize()` 方法会一直失败，抛出 `MalformedURLException` 异常。

你怎么知道要调用的方法会抛出已检异常呢？可以查看这个方法的签名。如果签名中没有，但又必须处理或声明调用的方法抛出的异常时，Java 编译器会（通过编译错误消息）告诉你。

### 变长参数列表

方法可以声明为接受数量不定的参数，调用时也可以传入数量不定的参数。这种方法一般叫作变长参数方法。格式化打印方法 `System.out.printf()` 和 String 类相关的 `format()` 方法，以及 `java.lang.reflect` 中反射 API 的一些重要方法，都使用变长参数。

变长参数列表的声明方式为，在方法最后一个参数的类型后面加上省略号（`...`），指明最后一个参数可以重复零次或多次。例如：

```java
public static int max(int first, int... rest) { 
    /* 暂时省略主体 */ 
}
```

变长参数方法纯粹由编译器处理，把数量不定的参数转换为一个数组。对 Java 运行时来说，上面的 `max()` 方法和下面这个没有区别：

```java
public static int max(int first, int[] rest) { 
    /* 暂时省略主体 */ 
}
```

把变长参数方法的签名转换为真正的签名，只需把 `...` 换成 `[]`。记住，参数列表中只能有一个省略号，而且只能出现在最后一个参数中。

下面填充 `max()` 方法的主体：

```java
public static int max(int first, int... rest) { 
    int max = first; 
    // 合法，因为rest其实就是数组
    for(int i : rest) {  
        if (i > max) max = i; 
    } 
    return max; 
}
```

声明这个 `max()` 方法时指定了两个参数，第一个是普通的 int 类型值，但是第二个可以重复零次或多次。下面对 `max()` 方法的调用都是合法的：

```java
max(0) 
max(1, 2) 
max(16, 8, 4, 2, 1)
```

因为变长参数方法被编译成接受数组参数的方法，所以在编译对这类方法的调用得到的代码中，包含创建和初始化这个数组的代码。因此，调用 `max(1,2,3)` 被编译成：

```java
max(1, new int[] { 2, 3 })
```

其实，如果参数的方法已经存储在数组中，完全可以直接把数组传给变长参数方法，而不用把数组中的元素取出来一个一个传入。`...` 参数可以看成一个数组。不过，反过来就不行了：**只有**使用省略号声明为变长参数方法，才能使用变长参数方法调用的句法。

## 类和对象

类是一段代码的名称，其中包含很多保存数据值的字段和操作这些值的方法。类是 Java 支持的五种引用类型之一，而且是最重要的一种。类是继方法之后的另一种高级句法。

关于类最重要的事情是，它们定义了一种新数据类型。例如，可以定义一个名为 Point 的类，表示笛卡尔二维坐标系中的数据点。这个类可能会定义两个字段，保存点的 x 和 y 坐标，还可能会定义处理和操作点的方法。Point 类就是一个新数据类型。

谈论数据类型时，要把数据类型和数据类型表示的值区分开，这一点很重要。char 是一种数据类型，用于表示 Unicode 字符。但是一个 char 类型的值表示某个具体的字符。类是一种数据类型，而类表示的值是对象。我们使用“类”这个名称的原因是，每个类定义一种对象。Point 类是一种数据类型，用于表示 (x, y) 点，而 Point 对象表示某个具体的 (x, y)点。正如你想得那样，类和类的对象联系紧密。

### 定义类

前面讨论的 Point 类可以使用下面的方式定义：

```java
/** 表示笛卡尔坐标系中的(x,y)点 */ 
public class Point { 
     // 点的坐标 
     public double x, y; 
    // 初始化字段的构造方法
     public Point(double x, double y) {     
         this.x = x; this.y = y; 
     } 
    // 操作x和y字段的方法
     public double distanceFromOrigin() {   
         return Math.sqrt(x*x + y*y); 
     } 
}
```

这个类的定义保存在一个名为 Point.java 的文件中，然后编译成一个名为 Point.class 的文件，供 Java 程序和其他类使用。

记住，你不需要定义想在 Java 程序中使用的每个类。Java 平台包含上千个预先定义好的类，在每台运行 Java 的电脑中都能使用。

### 创建对象

我们已经定义了 Point 类，现在 Point 是一种新数据类型，我们可以使用下面的代码声明一个变量，存储一个 Point 对象：

```java
Point p;
```

不过，声明一个存储 Point 对象的变量并不会创建这个对象。要想创建对象，必须使用`new` 运算符。这个关键字后面跟着对象所属的类（即对象的类型）和括号中可选的参数列表。这些参数会传入类的构造方法，初始化新对象的内部字段：

```java
// 创建一个Point对象，表示(2,-3.5) 
// 声明一个变量p，存储这个新Point对象的引用 
Point p = new Point(2.0, -3.5); 
 
// 创建一些其他类型的对象 
// 一个Date对象，表示当前时间 
Date d = new Date(); 
// 一个HashSet对象，保存一些对象 
Set words = new HashSet();
```

`new` 关键字是目前为止在 Java 中创建对象最常用的方式。还有一些其他方式也有必要提一下。首先，有些符合特定条件的类很重要，Java 为这些类定义了专用的字面量句法，用于创建这些类型的对象。其次，Java 支持动态加载机制，允许程序动态加载类和创建类的实例。最后，对象还可以通过反序列化创建。对象的状态可以保存或序列化到一个文件中，然后可以使用 `java.io.ObjectInputStream` 类重新创建这个对象。

### 使用对象

我们已经知道如何定义类，如何通过创建对象实例化类，现在要介绍使用对象的 Java 句法。前面说过，类定义了一些字段和方法。每个对象都有自己的字段副本，而且可以访问类中的方法。我们使用点号（`.`）访问对象的具名字段和方法。例如：

```java
Point p = new Point(2, 3);         // 创建一个对象 
double x = p.x;                    // 读取这个对象的一个字段 
p.y = p.x * p.x;                   // 设定一个字段的值 
double d = p.distanceFromOrigin(); // 访问这个对象的一个方法
```

这种句法在面向对象语言中很常见，Java 也不例外，因此会经常见到。特别注意一下 `p.distanceFromOrigin()`。这个表达式告诉 Java 编译器，查找一个名为`distanceFromOrigin()` 的方法（在 Point 类中定义），然后使用这个方法对 p 对象的字段进行计算。

### 对象字面量

介绍基本类型时我们看到，每种基本类型都有字面量句法，可以直接在程序的代码中插入各种类型的值。Java 还为一些特殊的引用类型定义了字面量句法，介绍如下。

#### 字符串字面量

String 类使用一串字符表示文本。因为程序经常需要通过文字和用户沟通，所以在任何编程语言中处理文本字符串的能力都十分重要。在 Java 中，字符串是对象，表示文本的数据类型是 String 类。现代 Java 程序使用的字符串数据通常比其他程序都多。

因为字符串是如此基本的数据类型，所以 Java 允许在程序中插入文本字面量，方法是把字符放在双引号（`"`）中。例如：

```java
String name = "David"; 
System.out.println("Hello, " + name);
```

> 别把字符串字面量两侧的双引号和字符字面量两侧的单引号搞混了。

字符串字面量可以包含字符字面量中能使用的任何一个转义序列。在双引号包围的字符串字面量中嵌入双引号时，转义序列特别有用。例如：

```java
String story = "\t\"How can you stand it?\" he asked sarcastically.\n";
```

字符串字面量中不能包含注释，而且只能有一行。Java 不支持把两行当成一行的任何接续字符。如果需要表示一串长文本，一行写不下，可以把这个文本拆成多个单独的字符串字面量，再使用 `+` 运算符把它们连接起来。例如：

```java
String s = "This is a test of the " +      // 要这么写 
           "emergency broadcast system";
```

这种字面量连接在编译程序时，而不是运行时完成，所以无需担心性能会降低。

#### 类型字面量

第二种支持专用对象字面量句法的类型是 Class 类。Class 类的实例表示一种 Java 数据类型，而且包含所表示类型的元数据。若想在 Java 程序中使用 Class 对象字面量，要在数据类型的名称后面加上 .class。例如：

```java
Class<?> typeInt = int.class; 
Class<?> typeIntArray = int[].class; 
Class<?> typePoint = Point.class;
```

#### `null`引用

`null` 关键字是一种特殊的字面量，引用不存在的值，或者不引用任何值。null 这个值是独一无二的，因为它是任何一种引用类型的成员。null 可以赋值给属于任何引用类型的变量。例如：

```java
String s = null; 
Point p = null;
```

### lambda表达式

Java 8 引入了一个重要的新功能——lambda 表达式。这是十分常见的编程语言结构，在函数式编程语言（Functional Programming Language，例如 Lisp、Haskell 和 OCaml）中使用范围极广。lambda 表达式的功能和灵活性远非局限于函数式语言，在几乎所有的现代编程语言中都能看到它的身影。

> lambda 表达式其实就是没有名称的函数，在 Java 中可以把它当成一个值。Java 不允许脱离类的概念运行方法，所以 lambda 表达式是在某个类中定义的匿名方法（开发者可能不知道具体是哪个类）。

lambda 表达式的句法如下：

```java
( paramlist ) -> { statements }
```

下面是一个十分传统的简单示例：

```java
Runnable r = () -> System.out.println("Hello World");
```

lambda 表达式当成值使用时，会根据要存储的变量类型，自动转换为相应的对象。自动转换和类型推导是 Java 实现 lambda 表达式的基础。但是，这要求正确地理解 Java 的整个类型系统。

下面是个稍微复杂的示例：

```java
ActionListener listener = (e) -> { 
  System.out.println("Event fired at: "+ e.getWhen()); 
  System.out.println("Event command: "+ e.getActionCommand()); 
};
```

## 包和Java命名空间

包由一些具名的类、接口和其他引用类型组成，目的是把相关的类组织在一起，并为这些类定义命名空间。

Java 平台的核心类放在一些名称以 java 开头的包中。例如，Java 语言最基本的类在 `java.lang` 包中，各种实用类在 `java.util` 包中，输入输出类在 `java.io` 包中，网络类在 `java.net` 包中。有些包还包含子包，例如 `java.lang.reflect` 和 `java.util.regex`。甲骨文标准化的 Java 平台扩展一般在名称以 javax 开头的包中。有些扩展，例如 `javax.swing` 及其各种子包，后来集成到了核心平台中。最后，Java 平台还包含几个被认可的标准，这些包以标准制定方命名，例如 `org.w3c` 和 `org.omg`。

每个类都有两个名称：一个是简称，定义时指定；另一个是完全限定名称，其中包含所在包的名称。例如，String 类是 `java.lang` 包的一部分，因此它的完全限定名称是 `java.lang.String`。

本节说明如何把自己的类和接口放到包里，以及如何选择包名，避免和其他人的包名有冲突。然后说明如何有选择性地把类型名称或静态成员导入命名空间，避免每次使用类或接口都要输入包名。

### 声明包

若想指定类属于哪个包，要使用 package 声明。如果 Java 文件中有 package 关键字，必须是 Java 代码的第一个标记（即除了注释和空格之外的第一个标记）。package 关键字后面是包的名称和一个分号。例如，有个 Java 文件以下述指令开头：

```java
package org.apache.commons.net;
```

那么，这个文件中定义的所有类都是 `org.apache.commons.net` 包的一部分。

如果 Java 文件中没有 package 指令，那么这个文件中定义的所有类都是一个默认的无名包的一部分。此时，类的限定名称和不限定名称相同。

> 包的名称有可能冲突，所以不要使用默认包。项目在增长的过程中越来越复杂，冲突几乎是不可避免的，所以最好从一开始就创建包。

### 全局唯一的包名

包的重要功能之一是划分 Java 命名空间，避免类名有冲突。例如，只能从包名上区分`java.util.List` 和 `java.awt.List` 两个类。不过，因此包名本身就要独一无二。作为 Java的开发方，甲骨文控制着所有以 java、javax 和 sun 开头的包名。

常用的命名方式之一是使用自己的域名，倒序排列各部分，作为包名的前缀。例如，Apache 项目开发了一个网络库，是 Apache Commons 项目的一部分。Commons 项目的网址是`http://commons.apache.org/`，因此这个网络库的包名是 `org.apache.commons.net`。

注意，API 开发者以前也使用这种包命名规则。如果其他程序员要把你开发的类和其他未知类放在一起使用，你的包名就要具有全局唯一性。如果你开发了一个 Java 程序，但是不会发布任何类供他人使用，那么你就知道部署这个应用需要使用的所有类，因此无需担心无法预料的命名冲突。此时，可以选择一种自己用着方便的命名方式，而不用考虑全局唯一性。常见的做法之一是，使用程序的名称作为主包的名称（主包里可能还有子包）。

### 导入类型

默认情况下，在 Java 代码中引用类或接口时，必须使用类型的完全限定名称，即包含包名。如果编写的代码需要使用 `java.io` 包中的 File 类处理文件，必须把这个类写成 `java.io.File`。不过这个规则有三个例外：

+ `java.lang` 包中的类型很重要也很常用，因此始终可以使用简称引用；
+ p.T 类型中的代码可以使用简称引用 p 包中定义的其他类型；
+ 已经使用 `import` 声明导入命名空间里的类型，可以使用简称引用。

前两个例外叫作“自动导入”。`java.lang` 包和当前包中的类型已经导入到命名空间里了，因此可以不加包名。输入不在 `java.lang` 包或当前包中的常用类型的包名，很快就会变得冗长乏味，因此要能显式地把其他包中的类型导入命名空间。这种操作通过 `import` 声明实现。

`import` 声明必须放在 Java 文件的开头，如果有 `package` 声明的话，要紧随其后，并且在任何类型定义之前。一个文件中能使用的 `import` 声明数量不限。`import` 声明应用于文件中的所有类型定义（但不应用于 `import` 声明中的类型）。

`import` 声明有两种格式。若想把单个类型导入命名空间，`import` 关键字后面是类型的名称和一个分号：

```java
import java.io.File;    // 现在不用输入java.io.File了，输入File就行
```

这种格式叫“单个类型导入”声明。`import` 声明的另一种格式是“按需类型导入”。在这种格式中，包名后面是 `.*` 字符，表示使用这个包里的任何类型时都不用输入包名。因此，如果除了 File 类之外，还要使用`java.io` 包中的其他几个类，可以导入整个包：

```java
import java.io.*;  // java.io包中的所有类都可以使用简称
```

按需导入句法对子包无效。如果导入了 `java.util` 包，仍然必须使用完全限定名称`java.util.zip.ZipInputStream` 引用这个类。按需导入类型和一个一个导入包中的所有类型作用不一样。按需导入更像是使用单个类型导入句法把代码中真正用到的各种类型从包中导入命名空间，因此才叫“按需”导入——用到某个类型时才会将其导入。
