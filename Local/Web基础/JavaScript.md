---
title: JavaScript
date: 2019-08-09 11:05:50
tags:
- JavaScript
categories:
- Web
summary: 参考书籍《JavaScript高级程序设计》第三版
---
## JavaScript概述

JavaScript（简称“JS”） 是一种具有函数优先的轻量级，解释型或即时编译型的编程语言。虽然它是作为开发Web页面的脚本语言而出名，但是它也被用到了很多非浏览器环境中，JavaScript 基于原型编程、多范式的动态脚本语言，并且支持面向对象、命令式和声明式（如函数式编程）风格。

ECMAScript是一种由 Ecma 国际（前身为欧洲计算机制造商协会，European Computer Manufacturers Association）通过ECMA-262标准化的脚本程序设计语言。这种语言在万维网上应用广泛，它往往被称为JavaScript或JScript，所以它可以理解为是JavaScript的一个标准，但实际上后两者是ECMA-262标准的实现和扩展。



## 基本概念

### JavaScript使用

HTML 中的脚本必须位于 `<script>` 与 `</script>` 标签之间。

脚本可被放置在 HTML 页面的 `<body>` 和 `<head>` 部分中。

`<script>`标签用于引入JavaScript，`<script>` 和 `</script>` 会告诉 JavaScript 在何处开始和结束。

`<script>`元素具有6个属性：

+ `async`：可选。异步，表示应该立即下载脚本，但不应妨碍页面中的其他操作，比如下载其他资源或等待加载其他脚本。只对外部脚本文件有效。建议异步脚本不要在加载期间修改 DOM（属性设置为`async="async"`）
+ `charset`：可选。表示通过 `src` 属性指定的代码的字符集。由于大多数浏览器会忽略它的值，因此这个属性很少有人用。
+ `defer`：可选。延迟，表示脚本可以**延迟到文档完全被解析和显示之后再执行**。只对外部脚本文件有效。IE7 及更早版本对嵌入脚本也支持这个属性。(属性设置为`defer="defer"`)
+ `language`：已废弃。原来用于表示编写代码使用的脚本语言（如 JavaScript、JavaScript1.2或 VBScript）。大多数浏览器会忽略这个属性，因此也没有必要再用了。
+ `src`：可选。表示包含要执行代码的外部文件。
+ `type`：可选。可以看成是`language `替代属性；表示编写代码使用的脚本语言的内容类型（也称为 MIME 类型）。如果没有指定这个属性，则其默认值为`text/javascript`


`<script>`通常用以下两种**使用方式**

+ 直接在页面中嵌入 JavaScript 代码

```html
<html>
<head>
  <script>
    alert('Hello, world');
  </script>
</head>
<body>
  ...
</body>
</html>
```
由`<script>`...`</script>`包含的代码就是JavaScript代码，它将直接被浏览器执行

+ 把JavaScript代码放到一个单独的`.js`文件，然后在HTML中通过`<script src="..."></script>`引入这个文件

```html
<html>
<head>
  <script src="/static/js/abc.js"></script>
</head>
<body>
  ...
</body>
</html>
```

这样，`/static/js/abc.js`就会被浏览器执行。

> 带有`src`属性的`<script>`元素不应该在其`<script>`和`</script>`标签之间再包含额外的 JavaScript 代码。如果包含了嵌入的代码，则只会下载并执行外部脚本文件，嵌入的代码会被忽略。

### 语法

JavaScript的语法和Java语言类似，每个语句以`;`结束，语句块用`{...}`。

但是，JavaScript并不强制要求在每个语句的结尾加`;`，浏览器中负责执行JavaScript代码的引擎会自动在每个语句的结尾补上`;`。推荐语句使用分号结束。

### 关键字和保留字

ECMA-262 描述了一组具有特定用途的关键字，这些关键字可用于表示控制语句的开始或结束，或者用于执行特定操作等。按照规则，关键字也是语言保留的，不能用作标识符。以下就是 ECMAScript
的全部关键字（带\*号上标的是第 5 版新增的关键字）：

| break      | do       | instanceof | typeof |
| ---------- | -------- | ---------- | ------ |
| case       | else     | new        | var    |
| catch      | finally  | return     | void   |
| continue   | for      | switch     | while  |
| debugger\* | function | this       | with   |
| default    | if       | throw      |        |
| delete     | in       | try        |        |

ECMA-262 还描述了另外一组不能用作标识符的保留字。尽管保留字在这门语言中还没有任何特定
的用途，但它们有可能在将来被用作关键字。用星号标记的关键词是 ECMAScript 5 和 6 中的新词。

| abstract | arguments  | await\*      | boolean   |
| -------- | ---------- | ------------ | --------- |
| break    | byte       | case         | catch     |
| char     | class\*    | const        | continue  |
| debugger | default    | delete       | do        |
| double   | else       | enum\*       | eval      |
| export\* | extends\*  | false        | final     |
| finally  | float      | for          | function  |
| goto     | if         | implements   | import\*  |
| in       | instanceof | int          | interface |
| let\*     | long       | native       | new       |
| null     | package    | private      | protected |
| public   | return     | short        | static    |
| super\*  | switch     | synchronized | this      |
| throw    | throws     | transient    | true      |
| try      | typeof     | var          | void      |
| volatile | while      | with         | yield     |

### 注释

ECMAScript 使用 C 风格的注释，包括单行注释和块级注释。

以`//`开头直到行末的字符被视为单行注释

另一种块注释是用`/*...*/`把多行字符包裹起来，把一大“块”视为一个注释

```javascript
// 单行注释
/*
 * 多
 * 行
 * 注
 * 释
*/
```

> 虽然上面注释中的第二和第三行都以一个星号开头，但这不是必需的。之所以添加那两个星号，纯粹是为了提高注释的可读性（这种格式在企业级应用中用得比较多）。

### 区分大小写

JavaScript**严格区分大小写**，如果弄错了大小写，程序将报错或者运行不正常。这也就意味着，变量名 test 和变量名 Test 分别表示两个不同的变量，而函数名不能使用 typeof，因为它是一个关键字，但 typeOf 则完全可以是一个有效的函数名。

### 标识符

标识符是指变量、函数、属性的名字，或者函数的参数。

标识符可以是按照下列格式规则组合起来的一或多个字符：

+ 第一个字符必须是一个字母、下划线（\_）或一个美元符号（$）；
+ 其他字符可以是字母、下划线、美元符号或数字

推荐采用驼峰大小写格式，也就是第一个字母小写，剩下的每个单词的首字母大写

> 不能把关键字、保留字、true、false 和 null 用作标识符。

### 严格模式

ECMAScript 5引入了严格模式的概念。

严格模式是为 JavaScript 定义了一种不同的解析与执行模型。通过严格模式，可以在函数内部选择进行较为严格的全局或局部的错误条件检测。使用严格模式的好处是可以提早知道代码中存在的错误，及时捕获一些可能导致编程错误ECMAScript 行为。 理解严格模式的规则非常重要，ECMAScript 的下一个版本将以严格模式为基础制定。

#### 选择使用

在严格模式下，ECMAScript3 中的一些不确定的行为将得到处理，而且对某些不安全的操作也会抛出错误。要在整个脚本中启用严格模式，可以在**顶部**添加如下代码： `"use strict";`

这行代码看起来像是字符串，而且也没有赋值给任何变量，但其实它是一个编译指示（pragma），用于告诉支持的 JavaScript 引擎切换到严格模式。这是为不破坏 ECMAScript 3 语法而特意选定的语法。

也可以只在函数中打开严格模式，就像下面这样： 
```javascript
function doSomething(){ 
    "use strict"; 
    //其他代码 
}
```
严格模式下，JavaScript 的执行结果会有很大不同，以下指出严格模式下的部分区别：

#### 变量

在严格模式下，什么时候创建变量以及怎么创建变量都是有限制的。首先，不允许意外创建全局变量。在非严格模式下，可以像下面这样创建全局变量：

```javascript
//未声明变量 
//非严格模式：创建全局变量 
//严格模式：抛出 ReferenceError 
 
message = "Hello world! ";
```

即使 message 前面没有 `var` 关键字，即使没有将它定义为某个全局对象的属性，也能将 message 创建为全局变量。但在严格模式下，如果给一个没有声明的变量赋值，那代码在执行时就会抛出
`ReferenceError`。

其次，不能对变量调用 delete 操作符。非严格模式允许这样操作，但会静默失败（返回 false）。而在严格模式下，删除变量也会导致错误。

```javascript
//删除变量  
//非严格模式：静默失败 
//严格模式：抛出 ReferenceError 
 
var color = "red"; 
delete color;
```

严格模式下对变量名也有限制。特别地，不能使用 implements、interface、let、package、private、protected、public、static 和 yield 作为变量名。这些都是保留字，将来的 ECMAScript 版本中可能会用到它们。在严格模式下，用以上标识符作为变量名会导致语法错误。

#### 对象

在严格模式下操作对象比在非严格模式下更容易导致错误。一般来说，非严格模式下会静默失败的情形，在严格模式下就会抛出错误。因此，在开发中使用严格模式会加大早发现错误的可能性。 
在下列情形下操作对象的属性会导致错误： 

+ 为只读属性赋值会抛出 `TypeError`；
+ 对不可配置的（nonconfigurable）的属性使用 delete 操作符会抛出 `TypeError`；
+ 为不可扩展的（nonextensible）的对象添加属性会抛出 `TypeError`。 

使用对象的另一个限制与通过对象字面量声明对象有关。在使用对象字面量时，属性名必须唯一。
例如：

```javascript
//重名属性 
//非严格模式：没有错误，以第二个属性为准 
//严格模式：抛出语法错误 
 
var person = {  
                name: "Nicholas", 
                name: "Greg" 
             };
```

这里的对象 `person` 有两个属性，都叫 `name`。在非严格模式下，`person` 对象的 `name` 属性值是第二个，而在严格模式下，这样的代码会导致语法错误。

#### 函数

首先，严格模式要求命名函数的参数必须唯一。以下面这个函数为例：

```javascript
//重名参数 
//非严格模式：没有错误，只能访问第二个参数 
//严格模式：抛出语法错误
function sum (num, num){ 
    //do something 
}
```

在非严格模式下，这个函数声明不会抛出错误。通过参数名只能访问第二个参数，要访问第一个参数必须通过 arguments 对象。 

在严格模式下，arguments 对象的行为也有所不同。在非严格模式下，修改命名参数的值也会反映到 arguments 对象中，而严格模式下这两个值是完全独立的。例如：

```javascript
//修改命名参数的值 
//非严格模式：修改会反映到 arguments 中 
//严格模式：修改不会反映到 arguments 中 
 
function showValue(value){ 
    value = "Foo";  
    alert(value);        //"Foo" 
    alert(arguments[0]); //非严格模式："Foo" 
                         //严格模式："Hi" 
} 
 
showValue("Hi");
```

以上代码中，函数 `showValue()` 只有一个命名参数 `value`。调用这个函数时传入了一个参数“Hi”，这个值赋给了 value。而在函数内部，value 被改为“Foo"。在非严格模式下，这个修改也会改变arguments[0]的值，但在严格模式下，arguments[0]的值仍然是传入的值。

### 变量

ECMAScript 的变量是松散类型的，所谓松散类型就是可以用来保存任何类型的数据。与Python变量类似。换句话说，
每个变量仅仅是一个用于保存值的占位符而已。

定义变量时要使用`var`操作符，后跟变量名（即一个标识符）：`var message;`。这行代码定义了一个名为`message` 的变量，该变量可以用来保存任何值，像这样未经过初始化的变量，会保存一个特殊的值—`undefined`。

```js
var message = "world"
function test() {
    var message = "hello"; // 局部变量
}
test();
console.log(message) //world
```

用 `var` 操作符定义的变量将成为定义该变量的作用域中的局部变量，如果在函数中使用 `var` 定义一个变量，那么这个变量在函数退出后就会被销毁。

```javascript
var message = "world"
function test() {
    message = "hello"; // 全局变量
}
test();
console.log(message) // hello
```

省略了 `var` 操作符，因而 `message` 就成了全局变量。这样，只要调用过一次 `test()` 函数，这个变量就有了定义，就可以在函数外部的任何地方被访问到。

> 不推荐省略`var`操作符定义全局变量

可以使用一条语句定义多个变量，变量间使用逗号分隔。

```javascript
var message = "hello", 
    found = false,
    age = 29;
```

这个例子定义并初始化了 3 个变量。同样由于 ECMAScript 是松散类型的，因而使用不同类型初始化变量的操作可以放在一条语句中来完成。虽然代码里的换行和变量缩进不是必需的，但这样做可以提高可读性。


## 数据类型

ECMAScript 中有 5 种简单数据类型（也称为基本数据类型）：`Undefined`、`Null`、`Boolean`、`Number`和 `String`。还有 1 种复杂数据类型——`Object`，`Object`本质上是由一组无序的名值对组成的。

JavaScript不区分整数和浮点数，统一用Number表示,以下都是合法的Number类型：

```javascript
123; // 整数123
0.456; // 浮点数0.456
1.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5
-99; // 负数
NaN; // NaN表示Not a Number，当无法计算结果时用NaN表示
Infinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity
```

> 十六进制表示整数比较方便，十六进制用0x前缀和0\~9，a\~f表示，例如：`0xff00`，`0xa5b4c3d2`，等等，它们和十进制表示的数值完全一样。

Number可以直接做四则运算，规则和数学一致

```javascript
1 + 2; // 3
(1 + 2) * 5 / 2; // 7.5
2 / 0; // Infinity
0 / 0; // NaN
10 % 3; // 1
10.5 % 3; // 1.5
// 注意%是求余运算
```

### `typeof`操作符

`typeof`操作符用来检测给定变量的数据类型，返回以下字符串

+ `undefined`——这个值未定义；
+ `boolean`——这个值是布尔值；
+ `string`——这个值是字符串；
+ `number`——这个值是数值；
+ `object`——这个值是对象或 null；
+ `function`——如果这个值是函数

下面是几个使用 `typeof` 操作符的例子：

```javascript
var message = "hello",found = false;
console.log(typeof message) // string
console.log(typeof(found))  // boolean
console.log(typeof 95);     // number
console.log(typeof null)    // object
```

`typeof` 操作符的操作数可以是变量（message），也可以是数值字面量。

> 注意，
> `typeof` 是一个操作符而不是函数，因此例子中的圆括号尽管可以使用，但不是必需的。

> 有些时候，`typeof` 操作符会返回一些令人迷惑但技术上却正确的值。比如，调用 `typeof null` 会返回“object"，因为特殊值 null 被认为是一个空的对象引用。Safari 5 及之前版本、Chrome 7 及之
> 前版本在对正则表达式调用 `typeof` 操作符时会返回“function"，而其他浏览器在这种情况下会返回
> “object"。

### `null`和`undefined`

`null`表示一个“空”的值，它和`0`以及空字符串`''`不同，`0`是一个数值，`''`表示长度为0的字符串，而`null`表示“空”。

`null`值表示一个空对象指针，而这也正是使用`typeof`操作符检测`null`值时会返回"object"的原因

在其他语言中，也有类似JavaScript的`null`的表示，例如Java也用`null`，Swift用`nil`，Python用`None`表示。但是，在JavaScript中，还有一个和`null`类似的`undefined`，它表示“未定义”。

JavaScript的设计者希望用`null`表示一个空的值，而`undefined`表示值未定义。事实证明，这并没有什么用，区分两者的意义不大。大多数情况下，我们都应该用`null`。`undefined`仅仅在判断函数参数是否传递的情况下有用。

只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存`null`值。这样做不仅可以体现`null`作为空对象指针的惯例，而且也有助于进一步区分`null`和 `undefined`。

```javascript
var message1; 
alert(message1 == undefined); //true

var message2 = undefined; 
alert(message2 == undefined); //true
```

###  `String`类型

字符串是以单引号`'`或双引号`"`括起来的任意文本，比如`'abc'`，`"xyz"`等等。`''`或`""`本身只是一种表示方式，不是字符串的一部分，因此，字符串`'abc'`只有`a`，`b`，`c`这3个字符。不过，以双引号开头的字符串也必须以双引号结尾，而以单引号开头的字符串必须以单引号结尾。

如果字符串内部既包含`'`又包含`"`，可以用转义字符`\`来标识

#### 字符字面量

String 数据类型包含一些特殊的字符字面量，也叫转义序列，用于表示非打印字符，或者具有其他用途的字符。这些字符字面量如下表所示：

| 字面量   | 含义                                                         |
| -------- | ------------------------------------------------------------ |
| `\n`     | 换行                                                         |
| `\t`     | Tab制表                                                      |
| `\b`     | 空格                                                         |
| `\r`     | 回车                                                         |
| `\f`     | 换页                                                         |
| `\\`     | 转义斜杠                                                     |
| `\'`     | 单引号（`'`），在用单引号表示的字符串中使用。                |
| `\"`     | 双引号（`"`），在用双引号表示的字符串中使用。                |
| `\xnn`   | 以十六进制代码 nn 表示的一个字符（其中n为0～F）。例如，\x41表示"A" |
| `\unnnn` | 以十六进制代码 nnnn 表示的一个Unicode字符（其中n为0～F）。例如，\u03a3表示希腊字符Σ |

这些字符字面量可以出现在字符串中的任意位置，而且也将被作为一个字符来解析，如下面的例子所示：

```javascript
var text = "\u03a3";
alert(text.length); // 输出 1
```

####  字符串的特点

ECMAScript 中的字符串是不可变的，也就是说，字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量，例如：

```javascript
var lang = "Java"; 
lang = lang + "Script";
```

以上示例中的变量 lang 开始时包含字符串“Java"。而第二行代码把 lang 的值重新定义为“Java"与“Script"的组合，即“JavaScript"。实现这个操作的过程如下：首先创建一个能容纳 10 个字符的新字符串，然后在这个字符串中填充“Java"和“Script"，最后一步是销毁原来的字符串“Java"和字符串“Script"，因为这两个字符串已经没用了。

#### 转换为字符串

要把一个值转换为一个字符串有两种方式。第一种是使用几乎每个值都有的 `toString()` 方法。这个方法唯一要做的就是返回相应值的字符串表现。来看下面的例子：

```javascript
var age = 11; 
var ageAsString = age.toString();         // 字符串"11" 
var found = true; 
var foundAsString = found.toString();     // 字符串"true"
```

数值、布尔值、对象和字符串值（没错，每个字符串也都有一个 `toString()` 方法，该方法返回字符串的一个副本）都有 `toString()` 方法。但 `null` 和 `undefined` 值没有这个方法。

多数情况下，调用 `toString()` 方法不必传递参数。但是，在调用数值的 `toString()` 方法时，可以传递一个参数：输出数值的基数。默认情况下，`toString()` 方法以十进制格式返回数值的字符串表示。而通过传递基数，`toString()` 可以输出以二进制、八进制、十六进制，乃至其他任意有效进制格式表示的字符串值。下面给出几个例子：

```javascript
var num = 10; 
alert(num.toString());         // "10" 
alert(num.toString(2));        // "1010" 
alert(num.toString(8));        // "12" 
alert(num.toString(10));       // "10" 
alert(num.toString(16));       // "a"
```

通过这个例子可以看出，通过指定基数，`toString()` 方法会改变输出的值。而数值 10 根据基数的不同，可以在输出时被转换为不同的数值格式。注意，默认的（没有参数的）输出值与指定基数 10 时的输出值相同。

在不知道要转换的值是不是 `null` 或 `undefined` 的情况下，还可以使用转型函数 `String()`，这个函数能够将任何类型的值转换为字符串。`String()`函数遵循下列转换规则：

+ 如果值有 `toString()` 方法，则调用该方法（没有参数）并返回相应的结果；
+ 如果值是 null，则返回“null"；
+ 如果值是 undefined，则返回“undefined"。

下面再看几个例子：

```javascript
var value1 = 10; 
var value2 = true; 
var value3 = null; 
var value4;

alert(String(value1));     // "10" 
alert(String(value2));     // "true" 
alert(String(value3));     // "null" 
alert(String(value4));     // "undefined"
```

这里先后转换了 4 个值：数值、布尔值、null 和 undefined。数值和布尔值的转换结果与调用 `toString()` 方法得到的结果相同。因为 null 和 undefined 没有 `toString()` 方法，所以 `String()` 函数就返回了这两个值的字面量。

> 要把某个值转换为字符串，可以使用加号操作符把它与一个字符串（`""`）加在一起。

#### 多行字符串

由于多行字符串用`\n`写起来比较费事，所以最新的ES6标准新增了一种多行字符串的表示方法，用反引号表示：

```javascript
`这是一个
多行
字符串`;
```

#### 模板字符串

要把多个字符串连接起来，可以用`+`号连接：

```javascript
var name = '小明';
var age = 20;
var message = '你好, ' + name + ', 你今年' + age + '岁了!';
alert(message);
```

如果有很多变量需要连接，用`+`号就比较麻烦。ES6新增了一种模板字符串，表示方法和上面的多行字符串一样，但是它会自动替换字符串中的变量：

```javascript
var name = '小明';
var age = 20;
var message = `你好, ${name}, 你今年${age}岁了!`;
alert(message);
```

#### 操作字符串

字符串常见的操作如下：

```javascript
var s = 'Hello, world!';
s.length; // 13
```

要获取字符串某个指定位置的字符，使用类似Array的下标操作，索引号从0开始：

```javascript
var s = 'Hello, world!';

s[0]; // 'H'
s[6]; // ' '
s[7]; // 'w'
s[12]; // '!'
s[13]; // undefined 超出范围的索引不会报错，但一律返回undefined
```

**需要特别注意的是**，字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果：

```javascript
var s = 'Test';
s[0] = 'X';
alert(s); // s仍然为'Test'
```

JavaScript为字符串提供了一些常用方法，注意，调用这些方法本身不会改变原有字符串的内容，而是返回一个新字符串：

##### toUpperCase

`toUpperCase()`把一个字符串全部变为大写：

```javascript
var s = 'Hello';
s.toUpperCase(); // 返回'HELLO'
```

##### toLowerCase

`toLowerCase()`把一个字符串全部变为小写：

```javascript
var s = 'Hello';
var lower = s.toLowerCase(); // 返回'hello'并赋值给变量lower
lower; // 'hello'
```

##### indexOf

`indexOf()`会搜索指定字符串出现的位置：

```javascript
var s = 'hello, world';
s.indexOf('world'); // 返回7
s.indexOf('World'); // 没有找到指定的子串，返回-1
```

##### substring

`substring()`返回指定索引区间的子串：

```javascript
var s = 'hello, world'
s.substring(0, 5); // 从索引0开始到5（不包括5），返回'hello'
s.substring(7); // 从索引7开始到结束，返回'world'
```

### `Boolean`类型

布尔值和布尔代数的表示完全一致，一个布尔值只有`true`、`false`两种值，要么是`true`，要么是`false`，可以直接用`true`、`false`表示布尔值，也可以通过布尔运算计算出来

+ `&&`运算是与运算，只有所有都为`true`，`&&`运算结果才是`true`
+ `||`运算是或运算，只要其中有一个为`true`，`||`运算结果就是`true`
+ `!`运算是非运算，它是一个单目运算符，把`true`变成`false`，`false`变成`true`

其他数据类型对于布尔值转换

| 数据类型  | true                   | false     |
| --------- | ---------------------- | --------- |
| Boolean   | true                   | false     |
| String    | 非空字符串             | “ ”       |
| Number    | 非零数字（包括无穷大） | 0和NaN    |
| Object    | 任何对象               | null      |
| Undefined | N/A                    | undefined |

### `Number`类型

默认十进制

八进制前两位为0o，八进制字面量在严格模式下是无效的，会导致支持的 JavaScript 引擎抛出错误。

十六进制前两位为0x

> 在进行算术计算时，所有以八进制和十六进制表示的数值最终都将被转换成十进制数值。

NaN（Not a Number），0除以 0会返回 NaN，因此不会影响其他代码的执行

NaN 与任何值都不相等，包括 NaN 本身，ECMAScript 定义了`isNaN()`函数

```javascript
console.log(100);  // 100
console.log(0o100); // 八进制的64
console.log(0xAB);  // 十六进制的171
console.log(0/0);   // NaN
console.log(1/0);   // Infinity
console.log(-1/0);  // -Infinity
```

#### 浮点数值

所谓浮点数值，就是该数值中必须包含一个小数点，并且小数点后面必须至少有一位数字。虽然小数点前面可以没有整数，但我们不推荐这种写法。以下是浮点数值的几个例子：

```javascript
var floatNum1 = 1.1; 
var floatNum2 = 0.1; 
var floatNum3 = .1;   // 有效，但不推荐
```

于保存浮点数值需要的内存空间是保存整数值的两倍，因此 ECMAScript 会不失时机地将浮点数值转换为整数值。显然，如果小数点后面没有跟任何数字，那么这个数值就可以作为整数值来保存。同样地，如果浮点数值本身表示的就是一个整数如 1.0），那么该值也会被转换为整数，如下面的例子所示：

```javascript
var floatNum1 = 1.;        // 小数点后面没有数字——解析为 1 
var floatNum2 = 10.0;      // 整数——解析为 10
```

对于那些极大或极小的数值，可以用 e 表示法（即科学计数法）表示的浮点数值表示。用 e 表示法表示的数值等于 e 前面的数值乘以 10 的指数次幂。ECMAScript 中 e 表示法的格式也是如此，即前面是一个数值（可以是整数也可以是浮点），中间是一个大写或小写的字母 E，后面是 10 的幂中的指数，该幂值将用来与前面的数相乘。下面是一个使用 e 表示法表示数值的例子：

```javascript
var floatNum = 3.125e7;  // 等于 31250000
```

在这个例子中，使用 e 表示法表示的变量 floatNum 的形式虽然简洁，但它的实际值则是 31250000。在此，e 表示法的实际含义就是“3.125 乘以 107”。

也可以使用 e 表示法表示极小的数值，如 0.00000000000000003，这个数值可以使用更简洁的 3e\-17 表示。在默认情况下，ECMASctipt 会将那些小数点后面带有 6 个零以上的浮点数值转换为以 e 表示法表示的数值（例如，0.0000003 会被转换成 3e\-7）。

浮点数值的最高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数。例如，0.1 加 0.2 的结果不是 0.3，而是 0.30000000000000004。这个小小的舍入误差会导致无法测试特定的浮点数值。

#### 数值范围

由于内存的限制，ECMAScript 并不能保存世界上所有的数值。
+ 能够表示的最小数值保存在`Number.MIN_VALUE` 中——在大多数浏览器中，这个值是 5e-324；
+ 能够表示的最大数值保存在 `Number.MAX_VALUE` 中——在大多数浏览器中，这个值是 1.7976931348623157e+308。

结果得到了一个超出 JavaScript 数值范围的值，那么这个数值将被自动转换成特殊的 Infinity 值。具体来说，如果这个数值是负数，则会被转换成-Infinity（负无穷），如果这个数值是正数，则会被转换成 Infinity（正无穷）。

如上所述，如果某次计算返回了正或负的 Infinity 值，那么该值将无法继续参与下一次的计算，因为 Infinity 不是能够参与计算的数值。要想确定一个数值是不是有穷的（换句话说，是不是位于最小和最大的数值之间），可以使用 `isFinite()` 函数。这个函数在参数位于最小与最大数值之间时会返回 true，如下面的例子所示：

```javascript
var result = Number.MAX_VALUE + Number.MAX_VALUE; 
alert(isFinite(result));  //false
```

尽管在计算中很少出现某些值超出表示范围的情况，但在执行极小或极大数值的计算时，检测监控这些值是可能的，也是必需的。

#### NaN

NaN，即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。例如，在其他编程语言中，任何数值除以 0 都会导致错误，从而停止代码执行。但在 ECMAScript 中，0除以 0 会返回 NaN，因此不会影响其他代码的执行。

NaN 本身有两个非同寻常的特点。首先，任何涉及 NaN 的操作（例如 `NaN/10`）都会返回 NaN，这个特点在多步计算中有可能导致问题。其次，NaN 与任何值都不相等，包括 NaN 本身。例如，下面的代码会返回 false：

```javascript
alert(NaN == NaN);   //false
```

针对 NaN 的这两个特点，ECMAScript 定义了 `isNaN()` 函数。这个函数接受一个参数，该参数可以是任何类型，而函数会帮我们确定这个参数是否“不是数值”。`isNaN()` 在接收到一个值之后，会尝试将这个值转换为数值。某些不是数值的值会直接转换为数值，例如字符串“10"或 Boolean 值。而任何不能被转换为数值的值都会导致这个函数返回 true。请看下面的例子：

```javascript
alert(isNaN(NaN));         //true 
alert(isNaN(10));          //false（10 是一个数值） 
alert(isNaN("10"));        //false（可以被转换成数值 10） 
alert(isNaN("blue"));      //true（不能转换成数值） 
alert(isNaN(true));        //false（可以被转换成数值 1）
```

这个例子测试了 5 个不同的值。测试的第一个值是 NaN 本身，结果当然会返回 true。然后分别测试了数值 10 和字符串"10"，结果这两个测试都返回了 false，因为前者本身就是数值，而后者可以被转换成数值。但是，字符串"blue"不能被转换成数值，因此函数返回了 true。由于 Boolean 值 true可以转换成数值 1，因此函数返回 false。

#### 数值转换

有 3 个函数可以把非数值转换为数值：`Number()` 、`parseInt()` 和 `parseFloat()` 。第一个函数，即转型函数 Number()可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值。这 3 个函数对于同样的输入会有返回不同的结果。

Number()函数的转换规则如下：

+ 如果是 Boolean 值，true 和 false 将分别被转换为 1 和 0。
+ 如果是数字值，只是简单的传入和返回。
+ 如果是 null 值，返回 0。
+ 如果是 undefined，返回 NaN。
+ 如果是字符串，遵循下列规则：
  + 如果字符串中只包含数字（包括前面带正号或负号的情况），则将其转换为十进制数值，即"1"会变成 1，"123"会变成 123，而"011"会变成 11（注意：前导的零被忽略了）；
  + 如果字符串中包含有效的浮点格式，如"1.1"，则将其转换为对应的浮点数值（同样，也会忽略前导零）；
  + 如果字符串中包含有效的十六进制格式，例如"0xf"，则将其转换为相同大小的十进制整数值；
  + 如果字符串是空的（不包含任何字符），则将其转换为 0；
  + 如果字符串中包含除上述格式之外的字符，则将其转换为 NaN。
+ 如果是对象，则调用对象的 `valueOf()` 方法，然后依照前面的规则转换返回的值。如果转换的结果是 `NaN`，则调用对象的 `toString()` 方法，然后再次依照前面的规则转换返回的字符串值。

根据这么多的规则使用 `Number()` 把各种数据类型转换为数值确实有点复杂。下面还是给出几个具体的例子：

```javascript
var num1 = Number("Hello world!");      // NaN 
var num2 = Number("");                  // 0 
var num3 = Number("000011");            // 11 
var num4 = Number(true);                // 1
```

+ 字符串“Hello world!"会被转换为 NaN，因为其中不包含任何有意义的数字值。
+ 空字符串会被转换为 0。
+ 字符串"000011"会被转换为 11，因为忽略了其前导的零。
+ true 值被转换为 1。

由于 `Number()` 函数在转换字符串时比较复杂而且不够合理，因此在处理整数的时候更常用的是`parseInt()` 函数。

`parseInt()` 函数在转换字符串时，更多的是看其是否符合数值模式。它会忽略字符串前面的空格，直至找到第一个非空格字符。如果第一个字符不是数字字符或者负号，`parseInt()` 就会返回 NaN；也就是说，用 `parseInt()` 转换空字符串会返回 NaN（`Number()`对空字符返回 0）。如果第一个字符是数字字符，`parseInt()` 会继续解析第二个字符，直到解析完所有后续字符或者遇到了一个非数字字符。例如，“1234blue" 会被转换为 1234，因为"blue"会被完全忽略。类似地，"22.5"会被转换为 22，因为小数点并不是有效的数字字符。

如果字符串中的第一个字符是数字字符，`parseInt()` 也能够识别出各种整数格式（即前面讨论的十进制、八进制和十六进制数）。也就是说，如果字符串以“0x"开头且后跟数字字符，就会将其当作一个十六进制整数；如果字符串以“0"开头且后跟数字字符，则会将其当作一个八进制数来解析。

下面给出一些例子：

```javascript
var num1 = parseInt("1234blue");    // 1234 
var num2 = parseInt("");            // NaN 
var num3 = parseInt("0xA");         // 10（十六进制数） 
var num4 = parseInt(22.5);          // 22 
var num5 = parseInt("070");         // 56（八进制数 ECMAScript 3） 
var num6 = parseInt("70");          // 70（十进制数） 
var num7 = parseInt("0xf");         // 15（十六进制数）
```

在使用 `parseInt()` 解析像八进制字面量的字符串时，ECMAScript 3 和 5 存在分歧。例如：

```javascript
//ECMAScript 3 认为是 56（八进制），ECMAScript 5 认为是 70（十进制） 
var num = parseInt("070");
```

在 ECMAScript 3 JavaScript 引擎中，“070" 被当成八进制字面量，因此转换后的值是十进制的 56。而在 ECMAScript 5 JavaScript 引擎中，`parseInt()` 已经不具有解析八进制值的能力，因此前导的零会被认为无效，从而将这个值当成 “70" ，结果就得到十进制的 70。在 ECMAScript 5 中，即使是在非严格模式下也会如此。

为了消除在使用 `parseInt()` 函数时可能导致的上述困惑，可以为这个函数提供第二个参数：转换时使用的基数（即多少进制）。如果知道要解析的值是十六进制格式的字符串，那么指定基数 16 作为第二个参数，可以保证得到正确的结果，例如：

```javascript
var num = parseInt("0xAF", 16);  //175
```

实际上，如果指定了 16 作为第二个参数，字符串可以不带前面的“0x"，如下所示：

```javascript
var num1 = parseInt("AF", 16);  //175 
var num2 = parseInt("AF");   //NaN
```

这个例子中的第一个转换成功了，而第二个则失败了。差别在于第一个转换传入了基数，明确告诉parseInt()要解析一个十六进制格式的字符串；而第二个转换发现第一个字符不是数字字符，因此就自动终止了。

指定基数会影响到转换的输出结果。例如：

```javascript
var num1 = parseInt("10", 2);     //2  （按二进制解析） 
var num2 = parseInt("10", 8);      //8  （按八进制解析） 
var num3 = parseInt("10", 10);     //10 （按十进制解析） 
var num4 = parseInt("10", 16);     //16 （按十六进制解析）
```

不指定基数意味着让 `parseInt()` 决定如何解析输入的字符串，因此为了避免错误的解析，我们建议无论在什么情况下都明确指定基数。

> 多数情况下，我们要解析的都是十进制数值，因此始终将 10 作为第二个参数是非常必要的。

与 `parseInt()` 函数类似，`parseFloat()` 也是从第一个字符（位置 0）开始解析每个字符。而且也是一直解析到字符串末尾，或者解析到遇见一个无效的浮点数字字符为止。也就是说，字符串中的第一个小数点是有效的，而第二个小数点就是无效的了，因此它后面的字符串将被忽略。举例来说，“22.34.5" 将会被转换为 22.34。

除了第一个小数点有效之外，`parseFloat()` 与 `parseInt()` 的第二个区别在于它始终都会**忽略前导的零**。`parseFloat()` 可以识别前面讨论过的所有浮点数值格式，也包括十进制整数格式。但十六进制格式的字符串则始终会被转换成 0。由于 `parseFloat()` **只解析十进制值**，因此它没有用第二个参数指定基数的用法。最后还要注意一点：如果字符串包含的是一个可解析为整数的数（没有小数点，或者小数点后都是零），`parseFloat()` 会返回整数。以下是使用 `parseFloat()` 转换数值的几个典型示例。

```javascript
var num1 = parseFloat("1234blue");        //1234 （整数） 
var num2 = parseFloat("0xA");              //0 
var num3 = parseFloat("22.5");             //22.5 
var num4 = parseFloat("22.34.5");          //22.34 
var num5 = parseFloat("0908.5");          //908.5 
var num6 = parseFloat("3.125e7");          //31250000
```

### Object类型

ECMAScript 中的对象其实就是一组数据和功能的集合。对象可以通过执行 new 操作符后跟要创建的对象类型的名称来创建。而创建 Object 类型的实例并为其添加属性和（或）方法，就可以创建自定义对象，如下所示：

```javascript
var o = new Object();
```

这个语法与 Java 中创建对象的语法相似；但在 ECMAScript 中，如果不给构造函数传递参数，则可以省略后面的那一对圆括号。也就是说，在像前面这个示例一样不传递参数的情况下，完全可以省略那对圆括号（但这不是推荐的做法）：

```javascript
var o = new Object; // 有效，但不推荐省略圆括号
```

仅仅创建 Object 的实例并没有什么用处，但关键是要理解一个重要的思想：即在 ECMAScript 中，（就像 Java 中的 `java.lang.Object` 对象一样）Object 类型是所有它的实例的基础。换句话说，Object 类型所具有的任何属性和方法也同样存在于更具体的对象中。

Object 的每个实例都具有下列属性和方法

+ `constructor`：保存着用于创建当前对象的函数。对于前面的例子而言，构造函数（constructor）就是 `Object()`。
+ `hasOwnProperty(propertyName)`：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名（`propertyName`）必须以字符串形式指定（例如：`o.hasOwnProperty("name")`）。
+ `isPrototypeOf(object)`：用于检查传入的对象是否是传入对象的原型。
+ `propertyIsEnumerable(propertyName)`：用于检查给定的属性是否能够使用 for-in 语句来枚举。与 `hasOwnProperty()`方法一样，作为参数的属性名必须以字符串形式指定。
+ `toLocaleString()`：返回对象的字符串表示，该字符串与执行环境的地区对应。
+ `toString()`：返回对象的字符串表示。
+ `valueOf()`：返回对象的字符串、数值或布尔值表示。通常与 `toString()` 方法的返回值相同。

由于在 ECMAScript 中 Object 是所有对象的基础，因此所有对象都具有这些基本的属性和方法。

> 从技术角度讲，ECMA-262 中对象的行为不一定适用于 JavaScript 中的其他对象。浏览器环境中的对象，比如 BOM 和 DOM 中的对象，都属于宿主对象，因为它们是由宿主实现提供和定义的。ECMA-262 不负责定义宿主对象，因此宿主对象可能会也可能不会继承 Object。

### 操作符

ECMA-262 描述了一组用于操作数据值的操作符，包括算术操作符（如加号和减号）、位操作符、关系操作符和相等操作符。ECMAScript 操作符的与众不同之处在于，它们能够适用于很多值，例如字符串、数字值、布尔值，甚至对象。不过，在应用于对象时，相应的操作符通常都会调用对象的 `valueOf()` 和（或）`toString()` 方法，以便取得可以操作的值。

#### 一元操作符

一元操作符只能操作一个值的操作符，是 ECMAScript 中最简单的操作符。

##### 自增和自减

递增和递减操作符直接借鉴自 C，而且各有两个版本：前置型和后置型。顾名思义，前置型应该位于要操作的变量之前，而后置型则应该位于要操作的变量之后。因此，在使用前置递增操作符给一个数值加 1 时，要把两个加号（++）放在这个数值变量前面，如下所示：

```javascript
var age = 29; 
++age;
```

在这个例子中，前置递增操作符把 age 的值变成了 30（为 29 加上了 1）。实际上，执行这个前置递增操作与执行以下操作的效果相同：

```javascript
var age = 29; 
age = age + 1;
```

执行前置递减操作的方法也类似，结果会从一个数值中减去 1。使用前置递减操作符时，要把两个减号（--）放在相应变量的前面，如下所示：

```javascript
var age = 29; 
--age;
```

这样，age 变量的值就减少为 28（从 29 中减去了 1）。

执行前置递增和递减操作时，变量的值都是在语句被求值以前改变的。（在计算机科学领域，这种情况通常被称作**副效应**。）请看下面这个例子：

```javascript
var age = 29; 
var anotherAge = --age + 2; 
 
alert(age);           // 输出 28 
alert(anotherAge);    // 输出 30
```

这个例子中变量 `anotherAge` 的初始值等于变量 `age` 的值前置递减之后加 2。由于先执行了减法操作，`age` 的值变成了 28，所以再加上 2 的结果就是 30。

由于前置递增和递减操作与执行语句的优先级相等，因此整个语句会从左至右被求值。再看一个例子：

```javascript
var num1 = 2; 
var num2 = 20; 
var num3 = --num1 + num2;      // 等于 21 
var num4 = num1 + num2;        // 等于 21
```

在这里，num3 之所以等于 21 是因为 num1 先减去了 1 才与 num2 相加。而变量 num4 也等于 21 是因为相应的加法操作使用了 num1 减去 1 之后的值。

后置型递增和递减操作符的语法不变（仍然分别是++和--），只不过要放在变量的后面而不是前面。后置递增和递减与前置递增和递减有一个非常重要的区别，即递增和递减操作是在包含它们的语句被求值之后才执行的。这个区别在某些情况下不是什么问题，例如：

```javascript
var age = 29; 
age++;
```

把递增操作符放在变量后面并不会改变语句的结果，因为递增是这条语句的唯一操作。

但是，当语句中还包含其他操作时，上述区别就会非常明显了。请看下面的例子：

```javascript
var num1 = 2; 
var num2 = 20; 
var num3 = num1-- + num2;     // 等于等于 22 
var num4 = num1 + num2;       // 等于 21
```

这里仅仅将前置递减改成了后置递减，就立即可以看到差别。在前面使用前置递减的例子中，num3 和 num4 最后都等于 21。而在这个例子中，num3 等于 22，num4 等于 21。差别的根源在于，这里在计算 num3 时使用了 num1 的原始值 2 完成了加法计算，而 num4 则使用了递减后的值 1 。

所有这 4 个操作符对任何值都适用，也就是它们不仅适用于整数，还可以用于字符串、布尔值、浮点数值和对象。在应用于不同的值时，递增和递减操作符遵循下列规则：

+ 在应用于一个包含有效数字字符的字符串时，先将其转换为数字值，再执行加减 1 的操作。字符串变量变成数值变量。
+ 在应用于一个不包含有效数字字符的字符串时，将变量的值设置为 NaN。字符串变量变成数值变量。
+ 在应用于布尔值 false 时，先将其转换为 0 再执行加减 1 的操作。布尔值变量变成数值变量。
+ 在应用于布尔值 true 时，先将其转换为 1 再执行加减 1 的操作。布尔值变量变成数值变量。
+ 在应用于浮点数值时，执行加减 1 的操作。
+ 在应用于对象时，先调用对象的 `valueOf()` 方法以取得一个可供操作的值。然后对该值应用前述规则。如果结果是 NaN，则在调用 `toString()` 方法后再应用前述规则。对象变量变成数值变量。

以下示例展示了上面的一些规则：

```javascript
var s1 = "2"; 
var s2 = "z"; 
var b = false; 
var f = 1.1; 
var o = {  
    valueOf: function() { 
        return -1; 
    } 
}; 
 
s1++;     // 值变成数值 3 
s2++;     // 值变成 NaN 
b++;      // 值变成数值 1 
f--;      // 值变成 0.10000000000000009（由于浮点舍入错误所致） 
o--;      // 值变成数值-2
```

##### 一元加和减操作符

绝大多数开发人员对一元加和减操作符都不会陌生，而且这两个 ECMAScript 操作符的作用与数学书上讲的完全一样。一元加操作符以一个加号（+）表示，放在数值前面，对数值不会产生任何影响，如下面的例子所示：

```javascript
var num = 25; 
num = +num;     // 仍然是 25
```

不过，在对非数值应用一元加操作符时，该操作符会像 `Number()` 转型函数一样对这个值执行转换。换句话说，布尔值 false 和 true 将被转换为 0 和 1，字符串值会被按照一组特殊的规则进行解析，而对象是先调用它们的 `valueOf()`和（或）`toString()` 方法，再转换得到的值。

下面的例子展示了对不同数据类型应用一元加操作符的结果：

```javascript
var s1 = "01"; 
var s2 = "1.1"; 
var s3 = "z"; 
var b = false; 
var f = 1.1; 
var o = { 
    valueOf: function() { 
        return -1; 
    } 
}; 
 
s1 = +s1;     // 值变成数值 1 
s2 = +s2;     // 值变成数值 1.1 
s3 = +s3;     // 值变成 NaN 
b = +b;       // 值变成数值 0 
f = +f;       // 值未变，仍然是 1.1 
o = +o;       // 值变成数值-1
```

一元减操作符主要用于表示负数，例如将 1 转换成-1。下面的例子演示了这个简单的转换过程：

```javascript
var num = 25; 
num = -num;    // 变成了-25
```

在将一元减操作符应用于数值时，该值会变成负数（如上面的例子所示）。而当应用于非数值时，一元减操作符遵循与一元加操作符相同的规则，最后再将得到的数值转换为负数，如下面的例子所示：

```javascript
var s1 = "01"; 
var s2 = "1.1"; 
var s3 = "z"; 
var b = false; 
var f = 1.1; 
var o = {
    valueOf: function() { 
        return -1; 
    }
}; 

s1 = -s1;         // 值变成了数值-1 
s2 = -s2;         // 值变成了数值-1.1 
s3 = -s3;         // 值变成了 NaN 
b = -b;           // 值变成了数值 0 
f = -f;           // 变成了-1.1 
o = -o;           // 值变成了数值 1
```

一元加和减操作符主要用于基本的算术运算，也可以像前面示例所展示的一样用于转换数据类型。

#### 位操作符

位操作符用于在最基本的层次上，即按内存中表示数值的位来操作数值。ECMAScript 中的所有数值都以 IEEE-754 64 位格式存储，但位操作符并不直接操作 64 位的值。而是先将 64 位的值转换成 32 位的整数，然后执行操作，最后再将结果转换回 64 位。对于开发人员来说，由于 64 位存储格式是透明的，因此整个过程就像是只存在 32 位的整数一样。

对于有符号的整数，32 位中的前 31 位用于表示整数的值。第 32 位用于表示数值的符号：0 表示正数，1 表示负数。这个表示符号的位叫做符号位，符号位的值决定了其他位数值的格式。其中，正数以纯二进制格式存储，31 位中的每一位都表示 2 的幂。第一位（叫做位 0）表示 2<sup>0</sup>，第二位表示 2<sup>1</sup>，以此类推 。 没有用到的位以 0 填充 ，即忽略不计 。

负数同样以二进制码存储，但使用的格式是二进制补码。计算一个数值的二进制补码，需要经过下列 3 个步骤：

+ 求这个数值绝对值的二进制码
+ 求二进制反码，即将 0 替换为 1，将 1 替换为 0；
+ 得到的二进制反码加 1。

要根据这 3 个步骤求得-18 的二进制码，首先就要求得 18 的二进制码，即：

```
0000 0000 0000 0000 0000 0000 0001 0010
```

然后，求其二进制反码，即 0 和 1 互换：

```
1111 1111 1111 1111 1111 1111 1110 1101
```

最后，二进制反码加 1：

```
1111 1111 1111 1111 1111 1111 1110 1101 
                                      1 
--------------------------------------- 
1111 1111 1111 1111 1111 1111 1110 1110
```

这样，就求得了-18 的二进制表示。要注意的是，在处理有符号整数时，是不能访问位 31 的。

ECMAScript 会尽力向我们隐藏所有这些信息。换句话说，在以二进制字符串形式输出一个负数时，我们看到的只是这个负数绝对值的二进制码前面加上了一个负号。如下面的例子所示：

```javascript
var num = -18; 
alert(num.toString(2));    // "-10010"
```

要把数值-18 转换成二进制字符串时，得到的结果是“-10010"。这说明转换过程理解了二进制补码并将其以更合乎逻辑的形式展示了出来。

在 ECMAScript 中，当对数值应用位操作符时，后台会发生如下转换过程：64 位的数值被转换成 32 位数值，然后执行位操作，最后再将 32 位的结果转换回 64 位数值。这样，表面上看起来就好像是在操作 32 位数值，就跟在其他语言中以类似方式执行二进制操作一样。但这个转换过程也导致了一个严重的副效应，即在对特殊的 NaN 和 Infinity 值应用位操作时，这两个值都会被当成 0 来处理。

如果对非数值应用位操作符，会先使用 `Number()` 函数将该值转换为一个数值（自动完成），然后再应用位操作。得到的结果将是一个数值。

① 按位非（NOT）

按位非操作符由一个波浪线（`~`）表示，执行按位非的结果就是返回数值的反码。按位非是 ECMAScript 操作符中少数几个与二进制计算有关的操作符之一。下面看一个例子：

```javascript
var num1 = 25;        // 二进制 00000000000000000000000000011001 
var num2 = ~num1;     // 二进制 11111111111111111111111111100110 
alert(num2);          // -26
```

这里，对 25 执行按位非操作，结果得到了-26。这也验证了按位非操作的本质：操作数的负值减 1。因此，下面的代码也能得到相同的结果：

```javascript
var num1 = 25; 
var num2 = -num1 - 1; 
alert(num2);            // "-26"
```

虽然以上代码也能返回同样的结果，但由于按位非是在数值表示的最底层执行操作，因此速度更快。

② 按位与（AND）

按位与操作符由一个和号字符（`&`）表示，它有两个操作符数。从本质上讲，按位与操作就是将两个数值的每一位对齐，然后根据下表中的规则，对相同位置上的两个数执行 AND 操作：

| 第一个数值的位 | 第二个数值的位 | 结果 |
| -------------- | -------------- | ---- |
| 1              | 1              | 1    |
| 1              | 0              | 0    |
| 0              | 1              | 0    |
| 0              | 0              | 0    |

简而言之，按位与操作只在两个数值的对应位都是 1 时才返回 1，任何一位是 0，结果都是 0。

下面看一个对 25 和 3 执行按位与操作的例子：

```javascript
var result = 25 & 3; 
alert(result);     //1
```

可见，对 25 和 3 执行按位与操作的结果是 1。为什么呢？请看其底层操作：

```
  25 = 0000 0000 0000 0000 0000 0000 0001 1001 
   3 = 0000 0000 0000 0000 0000 0000 0000 0011 
 --------------------------------------------- 
 AND = 0000 0000 0000 0000 0000 0000 0000 0001
```

原来，25 和 3 的二进制码对应位上只有一位同时是 1，而其他位的结果自然都是 0，因此最终结果等于 1。

③ 按位或（OR）

按位或操作符由一个竖线符号（`|`）表示，同样也有两个操作数。按位或操作遵循下面这个真值表。

| 第一个数值的位 | 第二个数值的位 | 结果 |
| -------------- | -------------- | ---- |
| 1              | 1              | 1    |
| 1              | 0              | 1    |
| 0              | 1              | 1    |
| 0              | 0              | 0    |

由此可见，按位或操作在有一个位是 1 的情况下就返回 1，而只有在两个位都是 0 的情况下才返回 0。

如果在前面按位与的例子中对 25 和 3 执行按位或操作，则代码如下所示：

```javascript
var result = 25 | 3; 
alert(result);       //27
```

25 与 3 按位或的结果是 27：

```javascript
25 = 0000 0000 0000 0000 0000 0000 0001 1001 
 3 = 0000 0000 0000 0000 0000 0000 0000 0011 
-------------------------------------------- 
OR = 0000 0000 0000 0000 0000 0000 0001 1011
```

这两个数值的都包含 4 个 1，因此可以把每个 1 直接放到结果中。二进制码 11011 等于十进制值 27。

④ 按位异或（XOR）

按位异或操作符由一个插入符号（`^`）表示，也有两个操作数。以下是按位异或的真值表。

| 第一个数值的位 | 第二个数值的位 | 结果 |
| -------------- | -------------- | ---- |
| 1              | 1              | 0    |
| 1              | 0              | 1    |
| 0              | 1              | 1    |
| 0              | 0              | 0    |

按位异或与按位或的不同之处在于，这个操作在两个数值对应位上只有一个 1 时才返回 1，如果对应的两位都是 1 或都是 0，则返回 0。

对 25 和 3 执行按位异或操作的代码如下所示：

```javascript
var result = 25 ^ 3; 
alert(result);    //26
```

25 与 3 按位异或的结果是 26，其底层操作如下所示：

```
   25 = 0000 0000 0000 0000 0000 0000 0001 1001 
    3 = 0000 0000 0000 0000 0000 0000 0000 0011 
 --------------------------------------------- 
 XOR  = 0000 0000 0000 0000 0000 0000 0001 1010
```

这两个数值都包含 4 个 1，但第一位上则都是 1，因此结果的第一位变成了 0。而其他位上的 1 在另一个数值中都没有对应的 1，可以直接放到结果中。二进制码 11010 等于十进制值 26（注意这个结果比执行按位或时小 1）。

⑤ 左移

左移操作符由两个小于号（`<<`）表示，这个操作符会将数值的所有位向左移动指定的位数。例如，
如果将数值 2（二进制码为 10）向左移动 5 位，结果就是 64（二进制码为 1000000），代码如下所示：

```javascript
var oldValue = 2;                      // 等于二进制的 10 
var newValue = oldValue << 5;          // 等于二进制的 1000000，十进制的 64
```

注意，在向左移位后，原数值的右侧多出了 5 个空位。左移操作会以 0 来填充这些空位，以便得到的结果是一个完整的 32 位二进制数。

```
0000 0000 0000 0000 0000 0000 0000 0010 // 2
0000 0000 0000 0000 0000 0000 0100 0000 // 64
```

注意，左移不会影响操作数的符号位。换句话说，如果将-2 向左移动 5 位，结果将是-64，而非 64。

⑥ 有符号的右移

有符号的右移操作符由两个大于号（`>>`）表示，这个操作符会将数值向右移动，但保留符号位（即正负号标记）。有符号的右移操作与左移操作恰好相反，即如果将 64 向右移动 5 位，结果将变回 2：

```javascript
var oldValue = 64;               // 等于二进制的 1000000 
var newValue = oldValue >> 5;    // 等于二进制的 10 ，即十进制的 2
```

同样，在移位过程中，原数值中也会出现空位。只不过这次的空位出现在原数值的左侧、符号位的右侧。而此时 ECMAScript 会用符号位的值来填充所有空位，以便得到一个完整的值。

⑦ 无符号右移

无符号右移操作符由 3 个大于号（`>>>`）表示，这个操作符会将数值的所有 32 位都向右移动。对正数来说，无符号右移的结果与有符号右移相同。仍以前面有符号右移的代码为例，如果将 64 无符号右移 5 位，结果仍然还是 2：

```javascript
var oldValue = 64;                // 等于二进制的 1000000 
var newValue = oldValue >>> 5;    // 等于二进制的 10 ，即十进制的 2
```

但是对负数来说，情况就不一样了。首先，无符号右移是以 0 来填充空位，而不是像有符号右移那样以符号位的值来填充空位。所以，对正数的无符号右移与有符号右移结果相同，但对负数的结果就不一样了。其次，无符号右移操作符会把负数的二进制码当成正数的二进制码。而且，由于负数以其绝对值的二进制补码形式表示，因此就会导致无符号右移后的结果非常之大，如下面的例子所示：

```javascript
var oldValue = -64;               // 等于二进制的等于二进制的 11111111111111111111111111000000 
var newValue = oldValue >>> 5;    // 等于十进制的 134217726
```

这里，当对-64 执行无符号右移 5 位的操作后，得到的结果是 134217726。之所以结果如此之大，是因为 -64 的二进制码为 11111111111111111111111111000000，而且无符号右移操作会把这个二进制码当成正数的二进制码，换算成十进制就是 4294967232。如果把这个值右移 5 位，结果就变成了 00000111111111111111111111111110，即十进制的 134217726。

#### 布尔操作符

在一门编程语言中，布尔操作符的重要性堪比相等操作符。如果没有测试两个值关系的能力，那么诸如 if...else 和循环之类的语句就不会有用武之地了。布尔操作符一共有 3 个：非（NOT）、与（AND）和或（OR）。

① 逻辑非

逻辑非操作符由一个叹号（`!`）表示，可以应用于 ECMAScript 中的任何值。无论这个值是什么数据类型，这个操作符都会返回一个布尔值。逻辑非操作符首先会将它的操作数转换为一个布尔值，然后再对其求反。也就是说，逻辑非操作符遵循下列规则：

+ 如果操作数是一个对象，返回 false；
+ 如果操作数是一个空字符串，返回 true；
+ 如果操作数是一个非空字符串，返回 false；
+ 如果操作数是数值 0，返回 true；
+ 如果操作数是任意非 0 数值（包括 Infinity），返回 false；
+ 如果操作数是 null，返回 true；
+ 如果操作数是 NaN，返回 true；
+ 如果操作数是 undefined，返回 true。

下面几个例子展示了应用上述规则的结果：

```javascript
alert(!false);       // true 
alert(!"blue");      // false 
alert(!0);           // true 
alert(!NaN);         // true 
alert(!"");          // true 
alert(!12345);       // false
```

逻辑非操作符也可以用于将一个值转换为与其对应的布尔值。而同时使用两个逻辑非操作符，实际上就会模拟 `Boolean()` 转型函数的行为。其中，第一个逻辑非操作会基于无论什么操作数返回一个布尔值，而第二个逻辑非操作则对该布尔值求反，于是就得到了这个值真正对应的布尔值。当然，最终结果与对这个值使用 `Boolean()` 函数相同，如下面的例子所示：

```javascript
alert(!!"blue");      //true 
alert(!!0);          //false 
alert(!!NaN);        //false 
alert(!!"");          //false 
alert(!!12345);      //true
```

② 逻辑与

逻辑与操作符由两个和号（`&&`）表示，有两个操作数，如下面的例子所示：

```javascript
var result = true && false;
```

逻辑与的真值表如下：

| 第一个操作数 | 第二个操作数 | 结果  |
| ------------ | ------------ | ----- |
| true         | true         | true  |
| true         | false        | false |
| false        | true         | false |
| false        | false        | false |

逻辑与操作可以应用于任何类型的操作数，而不仅仅是布尔值。在有一个操作数不是布尔值的情况下，逻辑与操作就不一定返回布尔值；此时，它遵循下列规则：

+ 如果第一个操作数是对象，则返回第二个操作数；
+ 如果第二个操作数是对象，则只有在第一个操作数的求值结果为 true 的情况下才会返回该对象；
+ 如果两个操作数都是对象，则返回第二个操作数；
+ 如果有一个操作数是 null，则返回 null；
+ 如果有一个操作数是 NaN，则返回 NaN；
+ 如果有一个操作数是 undefined，则返回 undefined。

逻辑与操作属于短路操作，即如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值。

对于逻辑与操作而言，如果第一个操作数是 false，则无论第二个操作数是什么值，结果都不再可能是 true 了。来看下面的例子：

```javascript
var found = true; 
var result = (found && someUndefinedVariable);    // 这里会发生错误 
alert(result);    // 这一行不会执行
```

在上面的代码中，当执行逻辑与操作时会发生错误，因为变量 `someUndefinedVariable` 没有声明。由于变量 `found` 的值是 `true`，所以逻辑与操作符会继续对变量 `someUndefinedVariable` 求值。但 `someUndefinedVariable` 尚未定义，因此就会导致错误。这说明不能在逻辑与操作中使用未定义的值。如果像下面这个例中一样，将 `found` 的值设置为 `false`，就不会发生错误了：

```javascript
var found = false; 
var result = (found && someUndefinedVariable);     // 不会发生错误 
alert(result);    // 会执行（"false"）
```

TODO P46

#### 关系操作符

当我们对Number做比较时，可以通过比较运算符得到一个布尔值：

```javascript
2 > 5; // false
5 >= 2; // true
7 == 7; // true
```

实际上，JavaScript允许对任意数据类型做比较：

```javascript
false == 0; // true
false === 0; // false
```

要特别注意相等运算符`==`。JavaScript在设计时，有两种比较运算符：

+ 第一种是`==`比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果；（类型不一样，值一样，会判断为true）
+ 第二种是`===`比较，它不会自动转换数据类型，如果数据类型不一致，返回`false`，如果一致，再比较。（类型和值都需要相等，才为true）

⭐由于JavaScript这个设计缺陷，**不要**使用`==`比较，始终坚持使用`===`比较。

另一个例外是`NaN`这个特殊的Number与**所有其他值都不相等，包括它自己**：

```javascript
NaN === NaN; // false
```

**唯一**能判断`NaN`的方法是通过`isNaN()`函数：

```javascript
isNaN(NaN); // true
```

最后要注意浮点数的相等比较：

```javascript
1 / 3 === (1 - 2 / 3); // false
```

这不是JavaScript的设计缺陷。浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值：

```javascript
Math.abs(1 / 3 - (1 - 2 / 3)) < 0.0000001; // true
```

### 数组

数组是一组按顺序排列的集合，集合的每个值称为元素。JavaScript的数组可以包括任意数据类型。例如：

```javascript
[1, 2, 3.14, 'Hello', null, true];
```

上述数组包含6个元素。数组用`[]`表示，元素之间用`,`分隔。

另一种创建数组的方法是通过`Array()`函数实现：

```javascript
new Array(1, 2, 3); // 创建了数组[1, 2, 3]
```

然而，出于代码的可读性考虑，强烈建议直接使用`[]`。

数组的元素可以通过索引来访问。请注意，索引的起始值为`0`：

```javascript
var arr = [1, 2, 3.14, 'Hello', null, true];
arr[0]; // 返回索引为0的元素，即1
arr[5]; // 返回索引为5的元素，即true
arr[6]; // 索引超出了范围，返回undefined
```

要取得`Array`的长度，直接访问`length`属性：

```javascript
var arr = [1, 2, 3.14, 'Hello', null, true];
arr.length; // 6
```

**请注意**，直接给`Array`的`length`赋一个新的值会导致`Array`大小的变化：

```javascript
var arr = [1, 2, 3];
arr.length; // 3
arr.length = 6;
arr; // arr变为[1, 2, 3, undefined, undefined, undefined]
arr.length = 2;
arr; // arr变为[1, 2]
```

`Array`可以通过索引把对应的元素修改为新的值，因此，对`Array`的索引进行赋值会直接修改这个`Array`：

```javascript
var arr = ['A', 'B', 'C'];
arr[1] = 99;
arr; // arr现在变为['A', 99, 'C']
```

**请注意**，如果通过索引赋值时，索引超过了范围，同样会引起`Array`大小的变化：

```javascript
var arr = [1, 2, 3];
arr[5] = 'x';
arr; // arr变为[1, 2, 3, undefined, undefined, 'x']
```

大多数其他编程语言不允许直接改变数组的大小，越界访问索引会报错。然而，JavaScript的`Array`却不会有任何错误。在编写代码时，不建议直接修改`Array`的大小，访问索引时要确保索引不会越界。

#### indexOf

与String类似，`Array`也可以通过`indexOf()`来搜索一个指定的元素的位置：

```javascript
var arr = [10, 20, '30', 'xyz'];
arr.indexOf(10); // 元素10的索引为0
arr.indexOf(20); // 元素20的索引为1
arr.indexOf(30); // 元素30没有找到，返回-1
arr.indexOf('30'); // 元素'30'的索引为2
```

注意了，数字`30`和字符串`'30'`是不同的元素。

#### slice

`slice()`就是对应String的`substring()`版本，它截取`Array`的部分元素，然后返回一个新的`Array`：

```javascript
var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];
arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']
arr.slice(3); // 从索引3开始到结束: ['D', 'E', 'F', 'G']
```

注意到`slice()`的起止参数包括开始索引，不包括结束索引。

如果不给`slice()`传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个`Array`：

```javascript
var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];
var aCopy = arr.slice();
aCopy; // ['A', 'B', 'C', 'D', 'E', 'F', 'G']
aCopy === arr; // false
```

#### push和pop

`push()`向`Array`的末尾添加若干元素，`pop()`则把`Array`的最后一个元素删除掉：

```javascript
var arr = [1, 2];
arr.push('A', 'B'); // 返回Array新的长度: 4
arr; // [1, 2, 'A', 'B']
arr.pop(); // pop()返回'B'
arr; // [1, 2, 'A']
arr.pop(); arr.pop(); arr.pop(); // 连续pop 3次
arr; // []
arr.pop(); // 空数组继续pop不会报错，而是返回undefined
arr; // []
```

#### unshift和shift

如果要往`Array`的头部添加若干元素，使用`unshift()`方法，`shift()`方法则把`Array`的第一个元素删掉：

```javascript
var arr = [1, 2];
arr.unshift('A', 'B'); // 返回Array新的长度: 4
arr; // ['A', 'B', 1, 2]
arr.shift(); // 'A'
arr; // ['B', 1, 2]
arr.shift(); arr.shift(); arr.shift(); // 连续shift 3次
arr; // []
arr.shift(); // 空数组继续shift不会报错，而是返回undefined
arr; // []
```

#### sort

`sort()`可以对当前`Array`进行排序，它会直接修改当前`Array`的元素位置，直接调用时，按照默认顺序排序：

```javascript
var arr = ['B', 'C', 'A'];
arr.sort();
arr; // ['A', 'B', 'C']
```

能否按照我们自己指定的顺序排序呢？完全可以，我们将在后面的函数中讲到。

#### reverse

`reverse()`把整个`Array`的元素给掉个个，也就是反转：

```javascript
var arr = ['one', 'two', 'three'];
arr.reverse(); 
arr; // ['three', 'two', 'one']
```

#### splice

`splice()`方法是修改`Array`的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素：

```javascript
var arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle'];
// 从索引2开始删除3个元素,然后再添加两个元素:
arr.splice(2, 3, 'Google', 'Facebook'); // 返回删除的元素 ['Yahoo', 'AOL', 'Excite']
arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']
// 只删除,不添加:
arr.splice(2, 2); // ['Google', 'Facebook']
arr; // ['Microsoft', 'Apple', 'Oracle']
// 只添加,不删除:
arr.splice(2, 0, 'Google', 'Facebook'); // 返回[],因为没有删除任何元素
arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']
```

#### concat

`concat()`方法把当前的`Array`和另一个`Array`连接起来，并返回一个新的`Array`：

```javascript
var arr = ['A', 'B', 'C'];
var added = arr.concat([1, 2, 3]);
added; // ['A', 'B', 'C', 1, 2, 3]
arr; // ['A', 'B', 'C']
```

**请注意**，`concat()`方法并没有修改当前`Array`，而是返回了一个新的`Array`。

实际上，`concat()`方法可以接收任意个元素和`Array`，并且自动把`Array`拆开，然后全部添加到新的`Array`里：

```javascript
var arr = ['A', 'B', 'C'];
arr.concat(1, 2, [3, 4]); // ['A', 'B', 'C', 1, 2, 3, 4]
```

#### join

`join()`方法是一个非常实用的方法，它把当前`Array`的每个元素都用指定的字符串连接起来，然后返回连接后的字符串：

```javascript
var arr = ['A', 'B', 'C', 1, 2, 3];
arr.join('-'); // 'A-B-C-1-2-3'
```

如果`Array`的元素不是字符串，将自动转换为字符串后再连接。

#### 多维数组

如果数组的某个元素又是一个`Array`，则可以形成多维数组，例如：

```javascript
var arr = [[1, 2, 3], [400, 500, 600], '-'];
```

### 对象

JavaScript的对象是一组由键-值组成的无序集合，例如：

```javascript
var person = {
    name: 'Bob',
    age: 20,
    tags: ['js', 'web', 'mobile'],
    city: 'Beijing',
    hasCar: true,
    zipcode: null // 每个属性用逗号隔开,最后一个不需要加逗号
};
```

JavaScript对象的键都是字符串类型，值可以是任意数据类型。上述`person`对象一共定义了6个键值对，其中每个键又称为对象的属性，例如，`person`的`name`属性为`'Bob'`，`zipcode`属性为`null`。

要获取一个对象的属性，我们用`对象变量.属性名`的方式：

```javascript
person.name; // 'Bob'
person.zipcode; // null
```

JavaScript用一个`{...}`表示一个对象，键值对以`xxx: xxx`形式申明，用`,`隔开。注意，最后一个键值对不需要在末尾加`,`，如果加了，有的浏览器（如低版本的IE）将报错。

访问属性是通过`.`操作符完成的，但这要求属性名必须是一个有效的变量名。如果属性名包含特殊字符，就必须用`''`括起来：

```javascript
var xiaohong = {
    name: '小红',
    'middle-school': 'No.1 Middle School'
};
```

`xiaohong`的属性名`middle-school`不是一个有效的变量，就需要用`''`括起来。访问这个属性也无法使用`.`操作符，必须用`['xxx']`来访问：

```javascript
xiaohong['middle-school']; // 'No.1 Middle School'
xiaohong['name']; // '小红'
xiaohong.name; // '小红'
```

如果访问一个不存在的属性会返回什么呢？JavaScript规定，访问不存在的属性不报错，而是返回`undefined`

如果我们要检测`xiaoming`是否拥有某一属性，可以用`in`操作符：

```javascript
var xiaoming = {
    name: '小明',
    birth: 1990,
    school: 'No.1 Middle School',
    height: 1.70,
    weight: 65,
    score: null
};
'name' in xiaoming; // true
'grade' in xiaoming; // false
```

不过要小心，如果`in`判断一个属性存在，这个属性不一定是`xiaoming`的，它可能是`xiaoming`继承得到的：

```javascript
'toString' in xiaoming; // true
```

因为`toString`定义在`object`对象中，而所有对象最终都会在原型链上指向`object`，所以`xiaoming`也拥有`toString`属性。

要判断一个属性是否是`xiaoming`自身拥有的，而不是继承得到的，可以用`hasOwnProperty()`方法：

```javascript
var xiaoming = {
    name: '小明'
};
xiaoming.hasOwnProperty('name'); // true
xiaoming.hasOwnProperty('toString'); // false
```

### 变量

变量的概念基本上和初中代数的方程变量是一致的，只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。

变量在JavaScript中就是用一个变量名表示，变量名是大小写英文、数字、`$`和`_`的组合，且不能用数字开头。变量名也不能是JavaScript的关键字，如`if`、`while`等。申明一个变量用`var`语句，比如：

```javascript
var a; // 申明了变量a，此时a的值为undefined
var $b = 1; // 申明了变量$b，同时给$b赋值，此时$b的值为1
var s_007 = '007'; // s_007是一个字符串
var Answer = true; // Answer是一个布尔值true
var t = null; // t的值是null
```

变量名也可以用中文，但是，请不要给自己找麻烦。

在JavaScript中，使用等号`=`对变量进行赋值。可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，但是要注意只能用`var`申明一次，例如：

```javascript
var a = 123; // a的值是整数123
a = 'ABC'; // a变为字符串
```

这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下：

```javascript
int a = 123; // a是整数类型变量，类型用int申明
a = "ABC"; // 错误：不能把字符串赋给整型变量
```

和静态语言相比，动态语言更灵活，就是这个原因。

请不要把赋值语句的等号等同于数学的等号。比如下面的代码：

```javascript
var x = 10;
x = x + 2;
```

如果从数学上理解`x = x + 2`那无论如何是不成立的，在程序中，赋值语句先计算右侧的表达式`x + 2`，得到结果`12`，再赋给变量`x`。由于`x`之前的值是`10`，重新赋值后，`x`的值变成`12`。

### strict模式

JavaScript在设计之初，为了方便初学者学习，并不强制要求用`var`申明变量。这个设计错误带来了严重的后果：如果一个变量没有通过`var`申明就被使用，那么该变量就自动被申明为全局变量：

```javascript
i = 10; // i现在是全局变量
```

在同一个页面的不同的JavaScript文件中，如果都不用`var`申明，恰好都使用了变量`i`，将造成变量`i`互相影响，产生难以调试的错误结果。

使用`var`申明的变量则不是全局变量，它的范围被限制在该变量被申明的函数体内（函数的概念将稍后讲解），同名变量在不同的函数体内互不冲突。

为了修补JavaScript这一严重设计缺陷，ECMA在后续规范中推出了strict模式，在strict模式下运行的JavaScript代码，强制通过`var`申明变量，未使用`var`申明变量就使用的，将导致运行错误。

启用strict模式的方法是在JavaScript代码的第一行写上：

```java
'use strict';
```

这是一个字符串，不支持strict模式的浏览器会把它当做一个字符串语句执行，支持strict模式的浏览器将开启strict模式运行JavaScript。

## 语句

### 条件判断

JavaScript使用`if () { ... } else { ... }`来进行条件判断。例如，根据年龄显示不同内容，可以用`if`语句实现如下：

```javascript
var age = 20;
if (age >= 18) { // 如果age >= 18为true，则执行if语句块
    alert('adult');
} else { // 否则执行else语句块
    alert('teenager');
}
```

其中`else`语句是可选的。如果语句块只包含一条语句，那么可以省略`{}`：

```javascript
var age = 20;
if (age >= 18)
    alert('adult');
else
    alert('teenager');
```

### 多行条件判断

如果还要更细致地判断条件，可以使用多个`if...else...`的组合：

```javascript
var age = 3;
if (age >= 18) {
    alert('adult');
} else if (age >= 6) {
    alert('teenager');
} else {
    alert('kid');
}
```

上述多个`if...else...`的组合实际上相当于两层`if...else...`：

```javascript
var age = 3;
if (age >= 18) {
    alert('adult');
} else {
    if (age >= 6) {
        alert('teenager');
    } else {
        alert('kid');
    }
}
```

### 循环

JavaScript的循环有两种，一种是`for`循环，通过初始条件、结束条件和递增条件来循环执行语句块：

```javascript
var x = 0;
var i;
for (i=1; i<=10000; i++) {
    x = x + i;
}
x; // 50005000
```

#### for

让我们来分析一下`for`循环的控制条件：

- `i = 1` 这是初始条件，将变量`i`置为1；
- `i <= 10000` 这是判断条件，满足时就继续循环，不满足就退出循环；
- `i++` 这是每次循环后的递增条件，由于每次循环后变量`i`都会加1，因此它终将在若干次循环后不满足判断条件`i<=10000`而退出循环。

`for`循环最常用的地方是利用索引来遍历数组：

```javascript
var arr = ['Apple', 'Google', 'Microsoft'];
var i, x;
for (i=0; i<arr.length; i++) {
    x = arr[i];
    console.log(x);
}
```

`for`循环的3个条件都是可以省略的，如果没有退出循环的判断条件，就必须使用`break`语句退出循环，否则就是死循环：

```javascript
var x = 0;
for (;;) { // 将无限循环下去
    if (x > 100) {
        break; // 通过if判断来退出循环
    }
    x ++;
}
```

#### for ... in

`for`循环的一个变体是`for ... in`循环，它可以把一个对象的所有属性依次循环出来：

```javascript
var o = {
    name: 'Jack',
    age: 20,
    city: 'Beijing'
};
for (var key in o) {
    console.log(key); // 'name', 'age', 'city'
}
```

要过滤掉对象继承的属性，用`hasOwnProperty()`来实现：

```javascript
var o = {
    name: 'Jack',
    age: 20,
    city: 'Beijing'
};
for (var key in o) {
    if (o.hasOwnProperty(key)) {
        console.log(key); // 'name', 'age', 'city'
    }
}
```

由于`Array`也是对象，而它的每个元素的索引被视为对象的属性，因此，`for ... in`循环可以直接循环出`Array`的索引：

```javascript
var a = ['A', 'B', 'C'];
for (var i in a) {
    console.log(i); // '0', '1', '2'
    console.log(a[i]); // 'A', 'B', 'C'
}
```

**请注意**，`for ... in`对`Array`的循环得到的是`String`而不是`Number`。

#### while

`for`循环在已知循环的初始和结束条件时非常有用。而上述忽略了条件的`for`循环容易让人看不清循环的逻辑，此时用`while`循环更佳。

`while`循环只有一个判断条件，条件满足，就不断循环，条件不满足时则退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现：

```javascript
var x = 0;
var n = 99;
while (n > 0) {
    x = x + n;
    n = n - 2;
}
x; // 2500
```

在循环内部变量`n`不断自减，直到变为`-1`时，不再满足`while`条件，循环退出。

#### do ... while

最后一种循环是`do { ... } while()`循环，它和`while`循环的唯一区别在于，不是在每次循环开始的时候判断条件，而是在每次循环完成的时候判断条件：

```javascript
var n = 0;
do {
    n = n + 1;
} while (n < 100);
n; // 100
```

用`do { ... } while()`循环要小心，循环体会至少执行1次，而`for`和`while`循环则可能一次都不执行。

#### break和continue

break 语句会立即退出循环， 强制继续执行循环后面的语句

continue 语句虽然也是立即退出循环，但退出循环后会从循环的顶部继续执行

### 其他

#### with语句

with 语句的作用是将代码的作用域设置到一个特定的对象中

由于大量使用 with 语句会导致性能下降，同时也会给调试代码造成困难，因此 在开发大型应用程序时，不建议使用 with 语句

#### switch语句

```javascript
switch (expression) {
    case value: statement
        break;
    case value: statement
        break;
    case value: statement
        break;
}
```

## 函数

```javascript
function functionName(arg0, arg1,...,argN) {
    statements
} 
```

使用`return`返回`return`后语句的返回值

参数，ECMAScript 函数不介意传递进来多少个参数，也不在乎传进来参数是什么数据类型

ECMAScript 函数不能像传统意义上那样实现重载

如果在 ECMAScript 中定义了两个名字相同的函数，则该名字只属于后定义的函数

```javascript
function addSomeNumber(num){
    return num + 100;
}
function addSomeNumber(num) {
    return num + 200;
}
var result = addSomeNumber(100); 
console.log(result); //300
```

通过检查传入函数中参数的类型和数量并作出不同的反应，可以模仿方法的重载