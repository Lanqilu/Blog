---
title: 深入理解计算机系统
tags:
  - null
categories:
  - []
abstract: "该文章已加密\U0001F512，如需访问请输入密码\U0001F511"
mathjax: false
date: 2020-07-31 17:12:19
password:
message:
---

{% note info no-icon %}

《深入了解计算机系统》笔记

{% endnote %}

<!-- more -->

---

## 计算机系统漫游

计算机系统是由硬件和系统软件组成的，它们共同工作来运行应用程序。虽然系统的具体实现方式随着时间不断变化，但是系统内在的概念却没有改变。所有计算机系统都有相似的硬件和软件组件，它们又执行着相似的功能。一些程序员希望深入了解这些组件是如何工作的以及这些组件是如何影响程序的正确性和性能的，以此来提高自身的技能。

+ 你将会学习一些实践技巧，比如如何避免由计算机表示数字的方式引起的奇怪的数字错误。
+ 你将学会怎样通过一些小窍门来优化自己的C代码，以充分利用现代处理器和存储器系统的设计。
+ 你将了解编译器是如何实现过程调用的，以及如何利用这些知识来避免缓冲区溢出错误带来的安全漏洞，这些弱点给网络和因特网软件带来了巨大的麻烦。
+ 你将学会如何识别和避免链接时那些令人讨厌的错误，它们困扰着普通的程序员。
+ 你将学会如何编写自己的 Unix shell、自己的动态存储分配包，甚至于自己的Web服务器。
+ 你会认识并发带来的希望和陷阱，这个主题随着单个芯片上集成了多个处理器核变得越来越重要

在 Kernighan和 Ritchie的哭于C编程语言的经典教材中，他们通过以下所示的hello程序来向读者介绍C。尽管he1lo程序非常简单，但是为了让它实现运行，系统的每个主要组成部分都需要协调工作。从某种意义上来说，本书的目的就是要帮助你了解当你在系统上执行hello程序时，系统发生了什么以及为什么会这样。

```c
#include <stdio.sh>

int main(){
    printf("hello,world\n");
    return 0;
}
```

我们通过跟踪hello程序的生命周期来开始对系统的学习——从它被程序员创建开始，到在系统上运行，输出简单的消息，然后终止。我们将沿着这个程序的生命周期，简要地介绍一些逐步出现的关键概念、专业术语和组成部分。

### 信息就是位+上下文

hello程序的生命周期是从一个**源程序**（或者说**源文件**）开始的，即程序员通过编辑器创建并保存的文本文件，文件名是 hello.c。源程序实际上就是一个由值0和1组成的**位**（又称为比特）序列，8个位被组织成一组，称为**字节**。每个字节表示程序中的某些文本字符。

hello.c程序是以字节序列的方式储存在文件中的。每个字节都有一个整数值，对应于某些字符。例如，第一个字节的整数值是35，它对应的就是字符“#”。第二个字节的整数值为105，它对应的字符是‘i’，依此类推。注意，每个文本行都是以一个看不见的换行符‘\n’来结束的，它所对应的整数值为10。像hello.c这样只由ASCII字符构成的文件称为**文本文件**，所有其他文件都称为**二进制文件**。

> 二进制文件和文本文件都是按照二进制存储的，只不过文本文件是把一个字节一个字节解读成字符，而二进制文件可以任意定义解读方式。

hello.c 的表示方法说明了一个基本思想：系统中所有的信息—包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示的。区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。比如，在不同的上下文中，一个同样的字节序列可能表示一个整数、浮点数、字符串或者机器指令。

### 程序被其他程序翻译成不同的格式

hello程序的生命周期是从一个高级C语言程序开始的，因为这种形式能够被人读懂。然而，为了在系统上运行hello.c程序，每条C语句都必须被其他程序转化为一系列的低级机器语言指令。然后这些指令按照一种称为可执行目标程序的格式打好包，并以二进制磁盘文件的形式存放起来。目标程序也称为**可执行目标文件**。

在Unix系统上，从源文件到目标文件的转化是由编译器驱动程序完成的：

```bash
linux> gcc -o hello hello.c
```

在这里，GCC编译器驱动程序读取源程序文件hello.c，并把它翻译成一个可执行目标文件hello。这个翻译过程可分为四个阶段完成。执行这四个阶段的程序（预处理器、编译器、汇编器和链接器）一起构成了编译系统（compilation system）。

+ 预处理阶段。预处理器（cpp）根据以字符`#`开头的命令，修改原始的C程序。比如hello.c中第1行的`# include< stdio.h>`命令告诉预处理器读取系统头文件stdio.h的内容，并把它直接插入程序文本中。结果就得到了另一个C程序，通常是以.i作为文件扩展名。

+ 编译阶段。编译器（cc1）将文本文件hello.i翻译成文本文件hello.s，它包含个汇编语言程序。该程序包含函数main的定义，如下所示：

  ```
  main：
    subq  $8, %rsq
    movl  $.LCO, %edi
    call  puts
    movl  $0, %eax
    addq  $8, %rsp
    ret
  ```

  定义中2\~7行的每条语句都以一种文本格式描述了一条低级机器语言指令。汇编语言是非常有用的，因为它为不同高级语言的不同编译器提供了通用的输出语言。例如，C编译器和 Fortran编译器产生的输出文件用的都是一样的汇编语言。

+ 汇编阶段。接下来，汇编器（as）将hello.s翻译成机器语言指令，把这些指令打包成种叫做可重定位目标程序（ relocatable object progran）的格式，并将结果保存在目标文件hello.o中。hello.o文件是一个二进制文件，它包含的17个字节是函数main的指令编码。如果我们在文本编辑器中打开hello.o文件，将看到一堆乱码。

+ 链接阶段。请注意，hello程序调用了 `printf`函数，它是每个C编译器都提供的标准C库中的一个函数。 `printf`函数存在于一个名为 printf.o的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的hello.o程序中。链接器（ld就负责处理这种合并。结果就得到hello文件，它是一个可执行目标文件
  （或者简称为可执行文件），可以被加载到内存中，由系统执行。

### 了解编译系统如何工作是大有益处的

对于像hello.c这样简单的程序，我们可以依靠编译系统生成正确有效的机器代码。但是，有一些重要的原因促使程序员必须知道编译系统是如何工作的。

+ 优化程序性能。现代编译器都是成熟的工具，通常可以生成很好的代码。作为程序员，我们无须为了写出高效代码而去了解编译器的内部工作。但是，为了在C程序中做出好的编码选择，我们确实需要了解一些机器代码以及编译器将不同的C语句转化为机器代码的方式。比如，
  + 一个 `switch`语句是否总是比一系列的`if-else`语句高效得多？
  + 一个函数调用的开销有多大？ `while`循环比`for`循环更有效吗？
  + 指针引用比数组索引更有效吗？
  + 为什么将循环求和的结果放到一个本地变量中，会比将其放到一个通过引用传递过来的参数中，运行起来快很多呢？
  + 为什么我们只是简单地重新排列下算术表达式中的括号就能让函数运行得更快？
+ 理解链接时出现的错误。根据我们的经验，一些最令人困扰的程序错误往往都与链接器操作有关，尤其是当你试图构建大型的软件系统时。比如，
  + 链接器报告说它无法解析一个引用，这是什么意思？
  + 静态变量和全局变量的区别是什么？
  + 如果你在不同的C文件中定义了名字相同的两个全局变量会发生什么？
  + 静态库和动态库的区别是什么？
  + 我们在命令行上排列库的顺序有什么影响？
  + 最严重的是，为什么有些链接错误直到运行时才会出现？
+ 避免安全漏洞。多年来，缓冲区溢出错误是造成大多数网络和 Internet服务器上安全漏洞的主要原因。存在这些错误是因为很少有程序员能够理解需要限制从不受信任的源接收数据的数量和格式。学习安全编程的第一步就是理解数据和控制信息存储在程序栈上的方式会引起的后果。

### 处理器读并解释储存在内存中的指令

此刻，hello.c源程序已经被编译系统翻译成了可执行目标文件hello，并被存放在磁盘上。要想在Unix系统上运行该可执行文件，我们将它的文件名输入到称为 shell的应用程序中：

```shell
linux>./he1lo 
hello. world 
linux>
```

shell是一个命令行解释器，它输出一个提示符，等待输人一个命令行，然后执行这个命令。如果该命令行的第一个单词不是一个内置的 shell命令，那么shell就会假设这是个可执行文件的名字，它将加载并运行这个文件。所以在此例中， shell将加载并运行hello程序，然后等待程序终止。 hello程序在屏幕上输出它的消息，然后终止。 shell随后输出一个提示符，等待下一个输入的命令行。

#### 系统的硬件组成



## 程序结构和执行



## 程序的机器级表示



## 处理器体系结构



## 优化程序性能



## 储存器层次结构



## 链接



## 异常控制流



## 虚拟内存



## 系统级I/O



## 网络编程



## 并发编程

